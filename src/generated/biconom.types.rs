// This file is @generated by prost-build.
/// UserPolicy определяет набор правил для группы пользователей.
/// Конкретная логика политики (например, требования к верификации) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `UserPolicy`.
pub mod user_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::UserPolicy>,
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Presence {
    #[prost(enumeration = "presence::Status", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `Presence`.
pub mod presence {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Пользователь онлайн прямо сейчас (менее 30 секунд назад)
        Online = 1,
        /// Был в сети недавно (от 30 секунд до 3 минут назад)
        Recently = 2,
        /// Был в сети в течение последнего часа (до 1 часа назад)
        LastHour = 3,
        /// Был в сети в течение сегодняшнего дня (до 24 часов назад)
        Today = 4,
        /// Был в сети в последние 3 дня
        LastFewDays = 5,
        /// Был в сети в течение последней недели
        LastWeek = 6,
        /// Был в сети давно (более недели)
        LongTimeAgo = 7,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Online => "ONLINE",
                Self::Recently => "RECENTLY",
                Self::LastHour => "LAST_HOUR",
                Self::Today => "TODAY",
                Self::LastFewDays => "LAST_FEW_DAYS",
                Self::LastWeek => "LAST_WEEK",
                Self::LongTimeAgo => "LONG_TIME_AGO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ONLINE" => Some(Self::Online),
                "RECENTLY" => Some(Self::Recently),
                "LAST_HOUR" => Some(Self::LastHour),
                "TODAY" => Some(Self::Today),
                "LAST_FEW_DAYS" => Some(Self::LastFewDays),
                "LAST_WEEK" => Some(Self::LastWeek),
                "LONG_TIME_AGO" => Some(Self::LongTimeAgo),
                _ => None,
            }
        }
    }
}
/// Модель данных для пользователя системы
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct User {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(enumeration = "presence::Status", tag = "2")]
    pub presence_status: i32,
    /// Политика, управляющая поведением пользователя.
    #[prost(uint32, tag = "3")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `User`.
pub mod user {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID пользователя
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// Элементы списка (пользователи)
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::User>,
    }
}
/// CommunityPolicy определяет набор правил для группы сообществ.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CommunityPolicy`.
pub mod community_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CommunityPolicy>,
    }
}
/// Модель данных для сообществ системы
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Community {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "community::Status", tag = "3")]
    pub status: i32,
    /// Политика, управляющая поведением сообщества.
    #[prost(uint32, tag = "4")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Community`.
pub mod community {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID сообщества
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное название сообщества
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    /// Список сообществ
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// Элементы списка (сообщества)
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Community>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Сообщество активно
        Active = 1,
        /// Временно заблокировано (например, нарушено правило)
        Suspended = 2,
        /// Архивировано, не допускает изменений и новых участников
        Archived = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Suspended => "SUSPENDED",
                Self::Archived => "ARCHIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "SUSPENDED" => Some(Self::Suspended),
                "ARCHIVED" => Some(Self::Archived),
                _ => None,
            }
        }
    }
}
/// AccountPolicy определяет набор правил для группы аккаунтов.
/// Конкретная логика политики (например, блокировка всех операций) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `AccountPolicy`.
pub mod account_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::AccountPolicy>,
    }
}
/// Account является универсальной учетной записью в системе.
/// Он представляет собой абстракцию, которая может ссылаться либо на пользователя (User),
/// либо на сообщество (Community), позволяя им выступать в роли владельцев других сущностей.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Account {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Политика, управляющая поведением аккаунта (включая права доступа).
    #[prost(uint32, tag = "4")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Тип владельца аккаунта
    #[prost(oneof = "account::Owner", tags = "2, 3")]
    pub owner: ::core::option::Option<account::Owner>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Уникальный ID аккаунта
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный ID пользователя
            #[prost(uint32, tag = "2")]
            UserId(u32),
            /// Уникальный ID сообщества
            #[prost(uint32, tag = "3")]
            CommunityId(u32),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Account>,
    }
    /// Тип владельца аккаунта
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Owner {
        /// Ссылка на пользователя
        #[prost(message, tag = "2")]
        User(super::User),
        /// Ссылка на сообщество
        #[prost(message, tag = "3")]
        Community(super::Community),
    }
}
/// BonusPolicy определяет набор правил для группы бонусов.
/// Конкретная логика расчета и начисления бонуса реализуется на бэкенде
/// и привязывается к этой политике по ее имени или ID.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BonusPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `BonusPolicy`.
pub mod bonus_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::BonusPolicy>,
    }
}
/// Bonus представляет собой справочную информацию о бонусе, существующем в системе.
/// Вся логика его расчета и начисления определяется в связанной BonusPolicy.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Bonus {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя бонуса (например, "Реферальный бонус")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Заголовок для отображения пользователю
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    /// Описание для отображения пользователю
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, определяющая правила расчета и начисления бонуса.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Bonus`.
pub mod bonus {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID бонуса
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя бонуса
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Bonus>,
    }
}
/// Boundary определяет граничное значение и его тип (включительно или исключительно).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Boundary {
    /// Значение границы (например, "1000").
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    /// Тип границы (включительно/исключительно).
    #[prost(enumeration = "boundary::Kind", tag = "2")]
    pub kind: i32,
}
/// Nested message and enum types in `Boundary`.
pub mod boundary {
    /// Определяет, включается ли граничное значение в диапазон.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        /// Тип не указан.
        Unspecified = 0,
        /// Включительно (>= или \<=).
        Inclusive = 1,
        /// Исключительно (> или \<).
        Exclusive = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Inclusive => "INCLUSIVE",
                Self::Exclusive => "EXCLUSIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUSIVE" => Some(Self::Inclusive),
                "EXCLUSIVE" => Some(Self::Exclusive),
                _ => None,
            }
        }
    }
}
/// Rounding определяет полные правила математического округления.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rounding {
    /// Режим округления.
    #[prost(enumeration = "rounding::Kind", tag = "1")]
    pub kind: i32,
    /// Количество знаков для округления. Положительное - после запятой, отрицательное - до запятой.
    #[prost(sint32, tag = "2")]
    pub precision: i32,
}
/// Nested message and enum types in `Rounding`.
pub mod rounding {
    /// Определяет математический режим округления.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        /// Режим не указан.
        Unspecified = 0,
        /// Математическое округление (к ближайшему целому, .5 округляется вверх).
        HalfUp = 1,
        /// Округление в меньшую сторону (к полу, floor).
        Floor = 2,
        /// Округление в большую сторону (к потолку, ceiling).
        Ceiling = 3,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::HalfUp => "HALF_UP",
                Self::Floor => "FLOOR",
                Self::Ceiling => "CEILING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "HALF_UP" => Some(Self::HalfUp),
                "FLOOR" => Some(Self::Floor),
                "CEILING" => Some(Self::Ceiling),
                _ => None,
            }
        }
    }
}
/// Calculation является инструкцией для динамического расчета суммы.
/// Это не самостоятельная сущность, а встраиваемая модель для описания правил.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Calculation {
    /// Правила постобработки, применяемые к результату.
    #[prost(message, optional, tag = "4")]
    pub post_processing: ::core::option::Option<calculation::PostProcessing>,
    /// Определяет вид/структуру калькуляции.
    #[prost(oneof = "calculation::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<calculation::Kind>,
}
/// Nested message and enum types in `Calculation`.
pub mod calculation {
    /// Simple описывает простой, линейный расчет.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Simple {
        /// Фиксированная часть (например, "5.00" USDT).
        #[prost(string, tag = "1")]
        pub fixed_value: ::prost::alloc::string::String,
        /// Процентная часть (например, "0.01" для 1%).
        #[prost(string, tag = "2")]
        pub percent_value: ::prost::alloc::string::String,
    }
    /// Tiered описывает многоуровневый расчет.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tiered {
        #[prost(enumeration = "tiered::Mode", tag = "1")]
        pub mode: i32,
        #[prost(message, repeated, tag = "2")]
        pub tiers: ::prost::alloc::vec::Vec<tiered::Tier>,
    }
    /// Nested message and enum types in `Tiered`.
    pub mod tiered {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Tier {
            #[prost(message, optional, tag = "1")]
            pub lower_bound: ::core::option::Option<super::super::Boundary>,
            #[prost(message, optional, tag = "2")]
            pub upper_bound: ::core::option::Option<super::super::Boundary>,
            #[prost(message, optional, tag = "3")]
            pub calculation: ::core::option::Option<super::Simple>,
        }
        /// Определяет, как применяется расчет в многоуровневой шкале.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            /// По достижению.
            Slab = 1,
            /// Прогрессивная.
            Progressive = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Slab => "SLAB",
                    Self::Progressive => "PROGRESSIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "SLAB" => Some(Self::Slab),
                    "PROGRESSIVE" => Some(Self::Progressive),
                    _ => None,
                }
            }
        }
    }
    /// Conditional позволяет реализовать логику "if-else".
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Conditional {
        #[prost(message, optional, tag = "1")]
        pub condition: ::core::option::Option<super::Boundary>,
        #[prost(message, optional, boxed, tag = "2")]
        pub if_true: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::Calculation>,
        >,
        #[prost(message, optional, boxed, tag = "3")]
        pub if_false: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::Calculation>,
        >,
    }
    /// PostProcessing определяет правила, применяемые к результату расчета.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PostProcessing {
        /// Минимальное значение результата (например, "комиссия не менее 10").
        #[prost(string, optional, tag = "1")]
        pub min_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Максимальное значение результата (например, "комиссия не более 100").
        #[prost(string, optional, tag = "2")]
        pub max_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Правила округления.
        #[prost(message, optional, tag = "3")]
        pub rounding: ::core::option::Option<super::Rounding>,
    }
    /// Определяет вид/структуру калькуляции.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Simple(Simple),
        #[prost(message, tag = "2")]
        Tiered(Tiered),
        #[prost(message, tag = "3")]
        Conditional(::prost::alloc::boxed::Box<Conditional>),
    }
}
/// CalculationGroup - это контейнер для нескольких независимых расчетов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationGroup {
    #[prost(map = "string, message", tag = "1")]
    pub calculations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Calculation,
    >,
    /// Правила постобработки, применяемые к ИТОГОВОЙ сумме.
    #[prost(message, optional, tag = "2")]
    pub post_processing: ::core::option::Option<calculation::PostProcessing>,
}
/// ConfirmationPolicy определяет набор правил для группы форм подтверждения.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfirmationPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Время жизни формы подтверждения в секундах.
    #[prost(uint32, tag = "4")]
    pub expires_in_seconds: u32,
    /// Максимальное количество попыток ввода данных.
    #[prost(uint32, tag = "5")]
    pub verification_attempt_limit: u32,
    /// Максимальное количество запросов на генерацию нового кода.
    #[prost(uint32, tag = "6")]
    pub code_generation_attempt_limit: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `ConfirmationPolicy`.
pub mod confirmation_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ConfirmationPolicy>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PasswordPolicy {
    /// ID политики
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Настройки политики
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<password_policy::Config>,
    /// Дата создания
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PasswordPolicy`.
pub mod password_policy {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Уникальный идентификатор политики паролей
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::PasswordPolicy>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PasswordReport {
        #[prost(bool, tag = "1")]
        pub is_valid: bool,
        #[prost(bool, tag = "2")]
        pub empty: bool,
        #[prost(bool, tag = "3")]
        pub too_short: bool,
        #[prost(bool, tag = "4")]
        pub too_long: bool,
        #[prost(bool, tag = "5")]
        pub group_satisfied: bool,
        #[prost(string, repeated, tag = "6")]
        pub forbidden: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "7")]
        pub denied: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Config {
        /// Минимально допустимая длина пароля
        #[prost(uint32, tag = "1")]
        pub min_length: u32,
        /// Максимально допустимая длина пароля
        #[prost(uint32, tag = "2")]
        pub max_length: u32,
        /// Битовая маска разрешённых классов символов.
        /// Например: (1 \<\< DIGITS) | (1 \<\< UPPERCASE) => 0b000101
        #[prost(uint32, tag = "3")]
        pub allowed_bit_mask: u32,
        /// Требуемые группы: хотя бы одна из групп должна быть полностью удовлетворена.
        /// Например: \[0b101\] означает DIGITS+UPPERCASE;
        /// \[0b101, 0b110\] означает: либо (DIGITS+UPPERCASE), либо (LOWERCASE+UPPERCASE)
        #[prost(uint32, repeated, tag = "4")]
        pub required_any_of_bit_mask: ::prost::alloc::vec::Vec<u32>,
    }
    /// Nested message and enum types in `Config`.
    pub mod config {
        /// Классы символов, используемые в паролях
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Character {
            /// Цифры: 0–9
            Digits = 0,
            /// Строчные латинские буквы: a–z
            Lowercase = 1,
            /// Заглавные латинские буквы: A–Z
            Uppercase = 2,
            /// Спецсимволы: !"#$%&'()\*+,-./:;\<=>?@\[\\\]^\_\`{|}~
            Special = 3,
            /// Эмодзи: Unicode ≥ 4 байт
            Emoji = 4,
        }
        impl Character {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Digits => "DIGITS",
                    Self::Lowercase => "LOWERCASE",
                    Self::Uppercase => "UPPERCASE",
                    Self::Special => "SPECIAL",
                    Self::Emoji => "EMOJI",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DIGITS" => Some(Self::Digits),
                    "LOWERCASE" => Some(Self::Lowercase),
                    "UPPERCASE" => Some(Self::Uppercase),
                    "SPECIAL" => Some(Self::Special),
                    "EMOJI" => Some(Self::Emoji),
                    _ => None,
                }
            }
        }
    }
}
/// SessionPolicy определяет набор правил безопасности и времени жизни для группы сессий.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SessionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Время жизни сессии в секундах. 0 означает "бессрочная".
    #[prost(uint32, tag = "4")]
    pub expires_in_seconds: u32,
    /// Время неактивности в секундах, после которого сессия истекает. 0 означает "не проверять".
    #[prost(uint32, tag = "5")]
    pub inactivity_timeout_seconds: u32,
    /// Максимальное количество одновременных активных сессий для одного пользователя.
    #[prost(uint32, tag = "6")]
    pub max_concurrent_sessions: u32,
    /// Требовать ли, чтобы IP-адрес сессии не менялся.
    #[prost(bool, tag = "7")]
    pub bind_to_ip: bool,
    #[prost(uint64, tag = "8")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SessionPolicy`.
pub mod session_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SessionPolicy>,
    }
}
/// Session представляет собой активную сессию пользователя в системе.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Session {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Текущий статус сессии.
    #[prost(enumeration = "session::Status", tag = "2")]
    pub status: i32,
    /// IP-адрес и geo данные.
    #[prost(message, optional, tag = "3")]
    pub geoip: ::core::option::Option<session::Geoip>,
    #[prost(string, optional, tag = "4")]
    pub os: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub device: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub browser: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "presence::Status", tag = "9")]
    pub presence_status: i32,
}
/// Nested message and enum types in `Session`.
pub mod session {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Geoip {
        /// IP-адрес, с которого была создана сессия.
        #[prost(string, tag = "1")]
        pub ip_address: ::prost::alloc::string::String,
        /// Код страны, полученное по IP.
        #[prost(string, optional, tag = "2")]
        pub country_iso: ::core::option::Option<::prost::alloc::string::String>,
        /// Название страны, полученное по IP.
        #[prost(string, optional, tag = "3")]
        pub country: ::core::option::Option<::prost::alloc::string::String>,
        /// Название города, полученное по IP.
        #[prost(string, optional, tag = "4")]
        pub city: ::core::option::Option<::prost::alloc::string::String>,
        /// Название промежуточных регионов (Штат/область), полученное по IP.
        #[prost(string, repeated, tag = "5")]
        pub subdivisions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID сессии.
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Session>,
    }
    /// Статус жизненного цикла сессии.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Сессия активна и используется.
        Active = 1,
        /// Сессия требует подтверждения (например, при входе с нового устройства).
        Pending = 2,
        /// Сессия была завершена пользователем (logout).
        Cancelled = 3,
        /// Сессия была принудительно завершена системой (например, при входе с нового устройства).
        Revoked = 4,
        /// Срок действия сессии истек (по времени или неактивности).
        Expired = 5,
        /// Принудительное завершение (система, модерация)
        Terminated = 6,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Pending => "PENDING",
                Self::Cancelled => "CANCELLED",
                Self::Revoked => "REVOKED",
                Self::Expired => "EXPIRED",
                Self::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PENDING" => Some(Self::Pending),
                "CANCELLED" => Some(Self::Cancelled),
                "REVOKED" => Some(Self::Revoked),
                "EXPIRED" => Some(Self::Expired),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
}
/// Network представляет собой основную партнерскую или дистрибьюторскую сеть.
/// Она служит контейнером для дистрибьюторов и их иерархических связей.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Network {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное строковое имя для идентификации сети
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ID корневой партиции (NetworkPartition) для данной сети
    #[prost(uint32, tag = "3")]
    pub root_partition_id: u32,
    /// Политика, управляющая поведением всей сети.
    #[prost(uint32, tag = "4")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Network`.
pub mod network {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации сети
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Различные способы идентификации сети
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID сети
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя сети
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Network>,
    }
}
/// Relationship представляет собой результат проверки иерархической связи между двумя объектами.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Relationship {
    /// Базовый ID элемента, от которого строим отношение.
    #[prost(uint32, tag = "1")]
    pub base_id: u32,
    /// ID целевого элемента, чье отношение к базовому описывается.
    #[prost(uint32, tag = "2")]
    pub target_id: u32,
    /// Состояние отношения между базовым и целевым элементами.
    #[prost(message, optional, tag = "3")]
    pub state: ::core::option::Option<relationship::State>,
}
/// Nested message and enum types in `Relationship`.
pub mod relationship {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct State {
        /// Тип отношения между объектами.
        #[prost(enumeration = "state::Kind", tag = "1")]
        pub kind: i32,
        /// Разница в уровнях (для TEAM и UPLINE).
        #[prost(uint32, optional, tag = "4")]
        pub level_diff: ::core::option::Option<u32>,
        /// Номер ветки, в которой находится дочерний объект (для TEAM).
        #[prost(uint32, optional, tag = "5")]
        pub branch_number: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `State`.
    pub mod state {
        /// Определяет тип иерархической связи.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            /// Отсутствие отношения между объектами.
            None = 0,
            /// Отношение не определено (например, один из объектов не найден).
            Error = 1,
            /// Тот же самый объект (сравнение объекта с самим собой).
            Personal = 2,
            /// Целевой объект является дочерним по отношению к базовому (в его команде).
            Team = 3,
            /// Целевой объект является родительским по отношению к базовому (в его спонсорской линии).
            Upline = 4,
            /// Объекты находятся в одной иерархии, но не связаны по вертикали (например, "братья").
            Sideways = 5,
            /// Объекты находятся в разных, не связанных иерархиях.
            Separate = 6,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Error => "ERROR",
                    Self::Personal => "PERSONAL",
                    Self::Team => "TEAM",
                    Self::Upline => "UPLINE",
                    Self::Sideways => "SIDEWAYS",
                    Self::Separate => "SEPARATE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "ERROR" => Some(Self::Error),
                    "PERSONAL" => Some(Self::Personal),
                    "TEAM" => Some(Self::Team),
                    "UPLINE" => Some(Self::Upline),
                    "SIDEWAYS" => Some(Self::Sideways),
                    "SEPARATE" => Some(Self::Separate),
                    _ => None,
                }
            }
        }
    }
}
/// Distributor представляет участника или узел в партнерской или дистрибьюторской сети.
/// Эта сущность связана с системным аккаунтом (Account) и может иметь иерархические связи.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Distributor {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное, человекочитаемое имя (псевдоним, бренд).
    #[prost(string, optional, tag = "2")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub invite_code: ::prost::alloc::string::String,
    /// ID вышестоящего дистрибьютора
    #[prost(uint32, tag = "4")]
    pub parent_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках вышестоящего дистрибьютора (parent_id)
    #[prost(uint32, tag = "5")]
    pub parent_entity_id: u32,
    /// Идентификатор ответвления от вышестоящего дистрибьютора (parent_id)
    #[prost(uint32, tag = "6")]
    pub parent_branch_id: u32,
    /// ID сети, к которому относится дистрибьютор
    #[prost(uint32, tag = "7")]
    pub network_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках сети (network_id)
    #[prost(uint32, tag = "8")]
    pub network_entity_id: u32,
    /// ID аккаунта, владеющего дистрибьютором
    #[prost(uint32, tag = "9")]
    pub account_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках аккаунта (account_id)
    #[prost(uint32, tag = "10")]
    pub account_entity_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках пары (network_id и account_id)
    #[prost(uint32, tag = "11")]
    pub network_account_entity_id: u32,
    /// ID партиции, к которому относится дистрибьютор
    #[prost(uint32, tag = "12")]
    pub network_partition_id: u32,
    /// Глобальный уровень глубины
    #[prost(uint32, tag = "13")]
    pub level: u32,
    /// Количество дочерних дистрибьюторов
    #[prost(uint32, tag = "14")]
    pub children_quantity: u32,
    /// Количество дистрибьюторов в структуре
    #[prost(uint32, tag = "15")]
    pub structure_quantity: u32,
    /// Максимальный уровень дистрибьютора в структуре
    #[prost(uint32, tag = "16")]
    pub structure_level_max: u32,
    /// ID политики, применяемой к этому дистрибьютору.
    #[prost(uint32, tag = "17")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "18")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "19")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "20")]
    pub relationship_state: ::core::option::Option<relationship::State>,
}
/// Nested message and enum types in `Distributor`.
pub mod distributor {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации дистрибьютора
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3, 4, 5, 6, 7")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentBranch {
            /// ID вышестоящего дистрибьютора
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Числовой идентификатор ветки
            #[prost(uint32, tag = "2")]
            pub parent_branch_number: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentEntity {
            /// ID вышестоящего дистрибьютора
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках вышестоящего дистрибьютора
            #[prost(uint32, tag = "2")]
            pub parent_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkEntity {
            /// ID сети, к которому относится дистрибьютор
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках сети (network_id)
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AccountEntity {
            /// ID аккаунта, владеющего дистрибьютором
            #[prost(uint32, tag = "1")]
            pub account_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках аккаунта (account_id)
            #[prost(uint32, tag = "2")]
            pub account_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkAccountEntity {
            /// ID сети, к которому относится дистрибьютор
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// ID аккаунта, владеющего дистрибьютором
            #[prost(uint32, tag = "2")]
            pub account_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках пары (network_id и account_id)
            #[prost(uint32, tag = "3")]
            pub network_account_entity_id: u32,
        }
        /// Различные способы идентификации дистрибьютора
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID дистрибьютора
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя дистрибьютора/бренда
            #[prost(string, tag = "2")]
            Username(::prost::alloc::string::String),
            #[prost(message, tag = "3")]
            ParentBranch(ParentBranch),
            #[prost(message, tag = "4")]
            ParentEntity(ParentEntity),
            #[prost(message, tag = "5")]
            NetworkEntity(NetworkEntity),
            #[prost(message, tag = "6")]
            AccountEntity(AccountEntity),
            #[prost(message, tag = "7")]
            NetworkAccountEntity(NetworkAccountEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Distributor>,
    }
}
/// Confirmation представляет собой одноразовую форму или сессию для подтверждения важного действия.
///
/// --- Вложенные типы и сообщения ----
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Confirmation {
    #[prost(uint64, optional, tag = "1")]
    pub id: ::core::option::Option<u64>,
    /// Уникальное имя действия (например, "WITHDRAWAL").
    #[prost(string, tag = "2")]
    pub action_name: ::prost::alloc::string::String,
    #[prost(enumeration = "confirmation::Status", tag = "3")]
    pub status: i32,
    /// Лимит попыток верификации для этой формы
    #[prost(uint32, tag = "4")]
    pub verification_attempt_limit: u32,
    /// Количество сделанных попыток верификации.
    #[prost(uint32, tag = "5")]
    pub verification_attempts_made: u32,
    /// Список всех доступных полей для этой формы.
    #[prost(message, repeated, tag = "6")]
    pub fields: ::prost::alloc::vec::Vec<confirmation::Field>,
    /// Битовая маска для групп полей, которые были успешно подтверждены.
    #[prost(uint32, optional, tag = "7")]
    pub approved_group_bit_mask: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Точное время, когда форма станет недействительной (рассчитывается на основе политики).
    #[prost(message, optional, tag = "9")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Гибкое поле для дополнительных данных.
    #[prost(message, optional, tag = "11")]
    pub metadata: ::core::option::Option<confirmation::Metadata>,
}
/// Nested message and enum types in `Confirmation`.
pub mod confirmation {
    /// Описание одного поля для верификации.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Field {
        /// Уникальный ID поля в рамках формы.
        #[prost(uint32, tag = "1")]
        pub id: u32,
        /// Битовая маска для группировки полей.
        #[prost(uint32, tag = "2")]
        pub group_bit_mask: u32,
        /// Тип поля (пароль, 2FA, чекбокс и т.д.).
        #[prost(enumeration = "field::Kind", tag = "3")]
        pub kind: i32,
        #[prost(oneof = "field::Config", tags = "4, 5, 6")]
        pub config: ::core::option::Option<field::Config>,
    }
    /// Nested message and enum types in `Field`.
    pub mod field {
        /// Детали генерации кодов для каналов связи.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Chanel {
            /// Тип канала связи (email, sms и т.д.).
            #[prost(enumeration = "chanel::Kind", tag = "1")]
            pub chanel_kind: i32,
            /// Значение канала связи (например, email адрес).
            #[prost(string, tag = "2")]
            pub chanel_contact: ::prost::alloc::string::String,
            /// Интервал между попытками генерации нового кода (в секундах).
            #[prost(uint32, tag = "3")]
            pub generation_duration: u32,
            /// Время генерации последнего кода.
            #[prost(message, optional, tag = "4")]
            pub last_generated_at: ::core::option::Option<::prost_types::Timestamp>,
            /// Лимит доступных попыток генерации нового кода.
            #[prost(uint32, tag = "5")]
            pub generation_attempt_limit: u32,
            /// Количество уже сделанных попыток генерации.
            #[prost(uint32, tag = "6")]
            pub generation_attempts_made: u32,
        }
        /// Nested message and enum types in `Chanel`.
        pub mod chanel {
            /// Типы контактного канала, на который отправляется код.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Kind {
                Unspecified = 0,
                Email = 1,
            }
            impl Kind {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::Email => "EMAIL",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "EMAIL" => Some(Self::Email),
                        _ => None,
                    }
                }
            }
        }
        /// Индексы позиций в мнемонической фразе, которые нужно заполнить.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MnemonicPositions {
            /// Список позиций (1 \<= N \<= 24) в мнемонической фразе.
            #[prost(uint32, repeated, tag = "1")]
            pub positions: ::prost::alloc::vec::Vec<u32>,
        }
        /// Типы полей, которые могут потребоваться для подтверждения.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            Unspecified = 0,
            /// Код, отправленный на канал связи (например, email).
            Chanel = 1,
            /// Пароль от аккаунта пользователя.
            Password = 2,
            /// Новый пароль для аккаунта пользователя.
            PasswordNew = 3,
            /// Чекбокс для подтверждения согласия с условиями.
            Agreement = 4,
            /// Код из приложения 2FA Google Authenticator.
            GoogleAuthenticatorCode = 5,
            /// Идентификаторы позиций в мнемонической фразе (mnemonic).
            MnemonicPositions = 6,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Chanel => "CHANEL",
                    Self::Password => "PASSWORD",
                    Self::PasswordNew => "PASSWORD_NEW",
                    Self::Agreement => "AGREEMENT",
                    Self::GoogleAuthenticatorCode => "GOOGLE_AUTHENTICATOR_CODE",
                    Self::MnemonicPositions => "MNEMONIC_POSITIONS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "CHANEL" => Some(Self::Chanel),
                    "PASSWORD" => Some(Self::Password),
                    "PASSWORD_NEW" => Some(Self::PasswordNew),
                    "AGREEMENT" => Some(Self::Agreement),
                    "GOOGLE_AUTHENTICATOR_CODE" => Some(Self::GoogleAuthenticatorCode),
                    "MNEMONIC_POSITIONS" => Some(Self::MnemonicPositions),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Config {
            /// Детали генерации кода для канала связи.
            #[prost(message, tag = "4")]
            Chanel(Chanel),
            /// Детали конфигурации пароля.
            #[prost(message, tag = "5")]
            PasswordPolicyConfig(super::super::password_policy::Config),
            /// Список позиций в мнемонической фразе.
            #[prost(message, tag = "6")]
            MnemonicPositions(MnemonicPositions),
        }
    }
    /// Идентификатор для поиска формы.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID формы.
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    /// Список форм подтверждения.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Confirmation>,
    }
    /// Запрос на генерацию одноразового кода для поля.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GenerateCodeRequest {
        /// ID формы подтверждения.
        #[prost(uint64, tag = "1")]
        pub confirmation_id: u64,
        /// ID поля, для которого нужно сгенерировать код.
        #[prost(uint32, tag = "2")]
        pub field_id: u32,
    }
    /// Запрос на подтверждение формы.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Form {}
    /// Nested message and enum types in `Form`.
    pub mod form {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Request {
            /// Глобальный ID формы для подтверждения.
            #[prost(uint64, tag = "1")]
            pub confirmation_id: u64,
            /// Список полей, которые отправляет пользователь.
            #[prost(message, repeated, tag = "2")]
            pub fields: ::prost::alloc::vec::Vec<request::Field>,
        }
        /// Nested message and enum types in `Request`.
        pub mod request {
            /// Поле, предоставленное пользователем для верификации.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Field {
                /// ID поля, которое заполняет пользователь.
                #[prost(uint32, tag = "1")]
                pub field_id: u32,
                #[prost(oneof = "field::Value", tags = "2, 3")]
                pub value: ::core::option::Option<field::Value>,
            }
            /// Nested message and enum types in `Field`.
            pub mod field {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Value {
                    /// Значение для полей типа пароль, код и т.д.
                    #[prost(string, tag = "2")]
                    StringValue(::prost::alloc::string::String),
                    /// Значение для чекбокса (должно быть `true`).
                    #[prost(bool, tag = "3")]
                    BoolValue(bool),
                }
            }
        }
        /// Ответ на запрос подтверждения формы.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Response {
            /// Общий статус подтверждения.
            #[prost(enumeration = "response::Status", tag = "1")]
            pub status: i32,
            /// Детальный результат по каждому полю.
            #[prost(message, repeated, tag = "2")]
            pub fields: ::prost::alloc::vec::Vec<response::Field>,
            /// Дополнительные данные, возвращаемые при успехе.
            #[prost(message, optional, tag = "3")]
            pub metadata: ::core::option::Option<response::Metadata>,
        }
        /// Nested message and enum types in `Response`.
        pub mod response {
            /// Результат проверки для одного поля.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Field {
                /// ID проверенного поля.
                #[prost(uint32, tag = "1")]
                pub field_id: u32,
                /// Статус проверки этого поля.
                #[prost(enumeration = "field::Status", tag = "2")]
                pub status: i32,
                #[prost(oneof = "field::Details", tags = "3")]
                pub details: ::core::option::Option<field::Details>,
            }
            /// Nested message and enum types in `Field`.
            pub mod field {
                /// Детальный статус для каждого отдельного поля.
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Status {
                    Unspecified = 0,
                    /// Поле заполнено верно.
                    Ok = 1,
                    /// Поле не заполнено, но является обязательным.
                    Empty = 2,
                    /// Поле заполнено неверно.
                    Wrong = 3,
                    /// Пользователь не согласился с условиями (чекбокс не `true`).
                    NotAgreed = 4,
                    /// Ранее пароль уже использовался и не может быть повторно использован.
                    PasswordAlreadyUsed = 5,
                }
                impl Status {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "UNSPECIFIED",
                            Self::Ok => "OK",
                            Self::Empty => "EMPTY",
                            Self::Wrong => "WRONG",
                            Self::NotAgreed => "NOT_AGREED",
                            Self::PasswordAlreadyUsed => "PASSWORD_ALREADY_USED",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "UNSPECIFIED" => Some(Self::Unspecified),
                            "OK" => Some(Self::Ok),
                            "EMPTY" => Some(Self::Empty),
                            "WRONG" => Some(Self::Wrong),
                            "NOT_AGREED" => Some(Self::NotAgreed),
                            "PASSWORD_ALREADY_USED" => Some(Self::PasswordAlreadyUsed),
                            _ => None,
                        }
                    }
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Details {
                    /// Детали валидации для полей (PASSWORD | PASSWORD_NEW)
                    #[prost(message, tag = "3")]
                    PasswordReport(
                        super::super::super::super::password_policy::PasswordReport,
                    ),
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Metadata {
                #[prost(string, optional, tag = "1")]
                pub authorization_bearer: ::core::option::Option<
                    ::prost::alloc::string::String,
                >,
            }
            /// Общий статус ответа на запрос подтверждения.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Status {
                Unspecified = 0,
                /// Форма успешно подтверждена.
                Approved = 1,
                /// Форма отклонена (одно или несколько полей неверны).
                Rejected = 2,
            }
            impl Status {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::Approved => "APPROVED",
                        Self::Rejected => "REJECTED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "APPROVED" => Some(Self::Approved),
                        "REJECTED" => Some(Self::Rejected),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Metadata {
        #[prost(oneof = "metadata::Identifier", tags = "1, 2, 3, 4")]
        pub identifier: ::core::option::Option<metadata::Identifier>,
    }
    /// Nested message and enum types in `Metadata`.
    pub mod metadata {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(string, tag = "1")]
            GoogleAuthenticatorSecret(::prost::alloc::string::String),
            #[prost(message, tag = "2")]
            Session(super::super::Session),
            #[prost(string, tag = "3")]
            MnemonicWords(::prost::alloc::string::String),
            #[prost(string, tag = "4")]
            AuthorizationBearer(::prost::alloc::string::String),
        }
    }
    /// Статус формы подтверждения.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Форма активна и ожидает подтверждения.
        Active = 1,
        /// Форма была успешно подтверждена.
        Approved = 2,
        /// В верификации было отказано (например, исчерпаны попытки).
        Rejected = 3,
        /// Форма была отменена пользователем или системой.
        Cancelled = 4,
        /// Срок действия формы истек.
        Expired = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Approved => "APPROVED",
                Self::Rejected => "REJECTED",
                Self::Cancelled => "CANCELLED",
                Self::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "APPROVED" => Some(Self::Approved),
                "REJECTED" => Some(Self::Rejected),
                "CANCELLED" => Some(Self::Cancelled),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
/// CurrencyPolicy определяет набор правил для группы валют.
/// Конкретная логика политики (например, требования к KYC для операций) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CurrencyPolicy`.
pub mod currency_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPolicy>,
    }
}
/// Currency представляет собой финансовую единицу, такую как криптовалюта или фиат.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Currency {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Полное название валюты (например, "Bitcoin")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный символ (тикер), например, "BTC"
    #[prost(string, tag = "3")]
    pub symbol: ::prost::alloc::string::String,
    /// Количество знаков после запятой для отображения и расчетов
    #[prost(uint32, tag = "4")]
    pub precision: u32,
    /// Вид валюты (крипто/фиат/балл).
    #[prost(enumeration = "currency::kind::Id", tag = "5")]
    pub kind: i32,
    /// Текущий операционный статус валюты
    #[prost(enumeration = "currency::status::Id", tag = "6")]
    pub status: i32,
    /// Политика, управляющая поведением валюты
    #[prost(uint32, tag = "7")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Currency`.
pub mod currency {
    /// Определяет операционный статус валюты.
    /// Эта модель-обертка позволяет в будущем расширять статус дополнительными полями (например, `reason`).
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {
        #[prost(enumeration = "status::Id", tag = "1")]
        pub id: i32,
    }
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Статус не определен.
            Unspecified = 0,
            /// Активна. Доступна для всех операций.
            Active = 1,
            /// Только просмотр/вывод. Новые депозиты и торговые операции невозможны.
            ViewOnly = 2,
            /// Тех. обслуживание. Операции временно приостановлены.
            Maintenance = 3,
            /// Неактивна. Полностью отключена, но может быть активирована.
            Inactive = 4,
            /// Устарела. Валюта больше не поддерживается и сохранена только для истории.
            Deprecated = 5,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::ViewOnly => "VIEW_ONLY",
                    Self::Maintenance => "MAINTENANCE",
                    Self::Inactive => "INACTIVE",
                    Self::Deprecated => "DEPRECATED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "VIEW_ONLY" => Some(Self::ViewOnly),
                    "MAINTENANCE" => Some(Self::Maintenance),
                    "INACTIVE" => Some(Self::Inactive),
                    "DEPRECATED" => Some(Self::Deprecated),
                    _ => None,
                }
            }
        }
    }
    /// Определяет основной вид валюты для применения общей логики.
    /// Имя `Kind` выбрано, чтобы избежать конфликтов с зарезервированным словом `Type`.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Kind {
        #[prost(enumeration = "kind::Id", tag = "1")]
        pub id: i32,
    }
    /// Nested message and enum types in `Kind`.
    pub mod kind {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Вид не указан.
            Unspecified = 0,
            /// Криптовалюта.
            Crypto = 1,
            /// Фиатная валюта.
            Fiat = 2,
            /// Внутренний балл.
            Point = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Crypto => "CRYPTO",
                    Self::Fiat => "FIAT",
                    Self::Point => "POINT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "CRYPTO" => Some(Self::Crypto),
                    "FIAT" => Some(Self::Fiat),
                    "POINT" => Some(Self::Point),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID валюты
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный символ (тикер), например, "BTC"
            #[prost(string, tag = "2")]
            Symbol(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Currency>,
    }
}
/// CurrencyPair представляет собой декларативную связь между двумя валютами.
/// Эта модель является справочной, но несет в себе операционный статус и ссылку на политику,
/// которые определяют правила для других систем, использующих эту пару (например, торговых).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyPair {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальный символ пары (например, "BTCUSDT")
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    /// ID базовой валюты (например, BTC)
    #[prost(uint32, tag = "3")]
    pub base_currency_id: u32,
    /// ID котируемой валюты (например, USDT)
    #[prost(uint32, tag = "4")]
    pub quote_currency_id: u32,
    /// Текущий операционный статус пары.
    #[prost(enumeration = "currency_pair::Status", tag = "5")]
    pub status: i32,
    /// Политика, управляющая правилами для этой пары.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `CurrencyPair`.
pub mod currency_pair {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID пары
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный символ пары, например, "BTCUSDT"
            #[prost(string, tag = "2")]
            Symbol(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPair>,
    }
    /// Определяет операционный статус торговой пары.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Активна. Торговля разрешена.
        Active = 1,
        /// Только просмотр. Новые ордера не принимаются, но можно просматривать историю.
        ViewOnly = 2,
        /// Тех. обслуживание. Торговля временно приостановлена.
        Maintenance = 3,
        /// Неактивна. Торговля приостановлена и может быть возобновлена.
        Inactive = 4,
        /// Устарела. Пара больше не поддерживается и скрыта из основных списков, но сохранена в системе для истории.
        Deprecated = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::ViewOnly => "VIEW_ONLY",
                Self::Maintenance => "MAINTENANCE",
                Self::Inactive => "INACTIVE",
                Self::Deprecated => "DEPRECATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "VIEW_ONLY" => Some(Self::ViewOnly),
                "MAINTENANCE" => Some(Self::Maintenance),
                "INACTIVE" => Some(Self::Inactive),
                "DEPRECATED" => Some(Self::Deprecated),
                _ => None,
            }
        }
    }
}
/// CurrencyPairPolicy определяет набор правил для группы валютных пар.
/// Конкретная логика политики (например, лимиты на торговлю, требования к марже) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyPairPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CurrencyPairPolicy`.
pub mod currency_pair_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPairPolicy>,
    }
}
/// DistributorPolicy определяет набор правил для группы дистрибьюторов.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DistributorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorPolicy`.
pub mod distributor_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorPolicy>,
    }
}
/// DistributorBranchPolicy определяет набор правил для группы веток дистрибьюторов.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DistributorBranchPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorBranchPolicy`.
pub mod distributor_branch_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorBranchPolicy>,
    }
}
/// DistributorBranch представляет собой иерархическую связь или "ветку" между дистрибьюторами.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DistributorBranch {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего дистрибьютора
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Числовой идентификатор ветки от вышестоящего дистрибьютора
    #[prost(uint32, tag = "3")]
    pub parent_branch_number: u32,
    /// ID дочернего дистрибьютора, если ветка занята
    #[prost(uint32, optional, tag = "4")]
    pub child_id: ::core::option::Option<u32>,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, управляющая поведением ветки.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorBranch`.
pub mod distributor_branch {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID ветки дистрибьютора
            #[prost(uint32, tag = "1")]
            Id(u32),
            #[prost(message, tag = "2")]
            ParentBranch(super::super::distributor::id::ParentBranch),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorBranch>,
    }
}
/// GoogleAuthenticatorPolicy определяет набор правил для группы настроек 2FA.
/// Конкретная логика политики (например, обязательность 2FA) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GoogleAuthenticatorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `GoogleAuthenticatorPolicy`.
pub mod google_authenticator_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::GoogleAuthenticatorPolicy>,
    }
}
/// GoogleAuthenticator представляет собой настройки двухфакторной аутентификации (2FA) для пользователя.
/// Эта модель НЕ содержит секретный ключ из соображений безопасности.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAuthenticator {
    /// Текущий статус настройки 2FA
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Текущее состояние запроса на изменение настроек 2FA
    #[prost(message, optional, tag = "2")]
    pub confirmation: ::core::option::Option<Confirmation>,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `GoogleAuthenticator`.
pub mod google_authenticator {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::GoogleAuthenticator>,
    }
}
/// Locale представляет собой языковую локаль, используемую в системе для интернационализации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Locale {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Полное название (например, "English (United States)")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный код по стандарту IETF BCP 47 (например, "en-US", "ar-SA").
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// Указывает, имеет ли язык написание справа налево (Right-to-Left).
    #[prost(bool, tag = "4")]
    pub is_rtl: bool,
    /// Текущий статус доступности локали
    #[prost(enumeration = "locale::Status", tag = "5")]
    pub status: i32,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Locale`.
pub mod locale {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID локали
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный код локали (например, "en-US")
            #[prost(string, tag = "2")]
            Code(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Locale>,
    }
    /// Определяет статус доступности локали.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Активна. Локаль доступна для выбора пользователями.
        Active = 1,
        /// Неактивна. Локаль скрыта и недоступна.
        Inactive = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Mnemonic представляет конфигурацию для мнемонических фраз.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mnemonic {
    /// enabled указывает, включена ли функция мнемонической фразы.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// confirmation представляет текущее состояние запроса на изменение настроек мнемонической фразы.
    #[prost(message, optional, tag = "2")]
    pub confirmation: ::core::option::Option<Confirmation>,
    /// created_at - время создания конфигурации мнемонической фразы.
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// updated_at - время последнего обновления конфигурации мнемонической фразы.
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Mnemonic`.
pub mod mnemonic {
    /// List представляет список мнемонических фраз.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// items содержит список мнемонических фраз.
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Mnemonic>,
    }
    /// Word представляет отдельное слово в мнемонической фразе.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Word {
        /// index - порядковый номер слова в мнемонической фразе (начиная с 0).
        ///
        /// Индекс слова в мнемонической фразе
        #[prost(uint32, tag = "1")]
        pub index: u32,
        /// value - само слово.
        ///
        /// Слово в мнемонической фразе
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Word`.
    pub mod word {
        /// List представляет список слов в мнемонической фразе.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            /// items содержит список слов.
            #[prost(message, repeated, tag = "1")]
            pub items: ::prost::alloc::vec::Vec<super::Word>,
        }
    }
}
/// NetworkPolicy определяет набор правил для группы сетей.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPolicy`.
pub mod network_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPolicy>,
    }
}
/// NetworkAccount представляет собой связь между сетью (Network) и универсальным аккаунтом (Account).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkAccount {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Идентификатор сети
    #[prost(uint32, tag = "2")]
    pub network_id: u32,
    /// Порядковый номер связи в рамках сети (network_id)
    #[prost(uint32, tag = "3")]
    pub network_entity_id: u32,
    /// Идентификатор аккаунта
    #[prost(uint32, tag = "4")]
    pub account_id: u32,
    /// Порядковый номер связи в рамках аккаунта (account_id)
    #[prost(uint32, tag = "5")]
    pub account_entity_id: u32,
    /// ID политики, применяемой к этой связи. Определяет ее статус и правила.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkAccount`.
pub mod network_account {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации связи
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Составной идентификатор для связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Pair {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Идентификатор аккаунта
            #[prost(uint32, tag = "2")]
            pub account_id: u32,
        }
        /// Различные способы идентификации связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID связи
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по паре сеть-аккаунт
            #[prost(message, tag = "2")]
            Pair(Pair),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkAccount>,
    }
}
/// NetworkAccountPolicy определяет набор правил для группы связей NetworkAccount.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkAccountPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkAccountPolicy`.
pub mod network_account_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkAccountPolicy>,
    }
}
/// NetworkPartition представляет собой выделенную часть или "партицию" внутри сети (Network).
/// Партиция начинается с определенного корневого дистрибьютора и может функционировать как отдельная подсеть.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkPartition {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID родительской сети
    #[prost(uint32, tag = "2")]
    pub network_id: u32,
    /// Порядковый номер партиции в рамках сети
    #[prost(uint32, tag = "3")]
    pub network_entity_id: u32,
    /// ID корневого дистрибьютора, с которого начинается партиция
    #[prost(uint32, tag = "4")]
    pub root_distributor_id: u32,
    /// Политика, управляющая поведением партиции (например, возможностью слияния).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    /// Флаг, указывающий, что партиция была слита с другой и больше не активна.
    #[prost(bool, tag = "6")]
    pub is_archived: bool,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPartition`.
pub mod network_partition {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации партиции
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по порядковому номеру в сети
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkEntity {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор партиции в рамках сети
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        /// Различные способы идентификации партиции
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID партиции
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по сети и порядковому номеру
            #[prost(message, tag = "2")]
            Entity(NetworkEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPartition>,
    }
}
/// NetworkPartitionPolicy определяет набор правил для группы партиций сети.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkPartitionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Определяет, могут ли партиции, подчиненные этой политике, быть слиты с другими. false - аналог "Standalone".
    #[prost(bool, tag = "4")]
    pub is_mergeable: bool,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "89")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPartitionPolicy`.
pub mod network_partition_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPartitionPolicy>,
    }
}
/// ReferralLinkPolicy определяет набор правил для группы реферальных ссылок.
/// Для коллективных ссылок, эта политика может описывать логику балансировщика.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReferralLinkPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint64, tag = "2")]
    pub trace_id: u64,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `ReferralLinkPolicy`.
pub mod referral_link_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ReferralLinkPolicy>,
    }
}
/// InviteLink представляет собой реферальную ссылку, используемую для привлечения новых участников.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InviteLink {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Уникальный код, используемый в URL (например, "REF123XYZ").
    #[prost(string, tag = "2")]
    pub invite_code: ::prost::alloc::string::String,
    /// Имя ссылки, видимое ее создателю.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Не изменяемая ссылка, которая не может быть изменена.
    #[prost(bool, tag = "4")]
    pub fixed: bool,
    /// Статус ссылки (активна/неактивна).
    #[prost(bool, tag = "5")]
    pub enabled: bool,
    #[prost(uint32, tag = "6")]
    pub account_id: u32,
    #[prost(uint32, tag = "7")]
    pub account_entity_id: u32,
    #[prost(uint32, tag = "8")]
    pub used_quantity: u32,
    #[prost(uint64, tag = "9")]
    pub cursor_pool_id: u64,
    #[prost(message, repeated, tag = "10")]
    pub pools: ::prost::alloc::vec::Vec<invite_link::Pool>,
    #[prost(message, optional, tag = "11")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `InviteLink`.
pub mod invite_link {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(uint64, tag = "1")]
            Id(u64),
            /// Уникальный код ссылки.
            #[prost(string, tag = "2")]
            InviteCode(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::InviteLink>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct View {
        /// Аккаунт, который является создателем и владельцем InviteLink.
        #[prost(uint32, tag = "1")]
        pub owner_account_id: u32,
        /// Аккаунты (который является владельцем InviteLink и Distributor).
        #[prost(message, repeated, tag = "2")]
        pub accounts: ::prost::alloc::vec::Vec<super::Account>,
        /// Сеть, к которой относится ссылка.
        #[prost(message, optional, tag = "3")]
        pub network: ::core::option::Option<super::Network>,
        /// Дистрибьютор-наставник.
        #[prost(message, optional, tag = "4")]
        pub distributor: ::core::option::Option<super::Distributor>,
        /// Найденный дистрибьютор, является статичным результатом или динамичным.
        #[prost(bool, tag = "5")]
        pub is_dynamic: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Pool {
        #[prost(uint64, tag = "1")]
        pub id: u64,
        #[prost(uint64, tag = "2")]
        pub invite_link_id: u64,
        #[prost(uint32, tag = "3")]
        pub invite_link_order_id: u32,
        #[prost(bool, tag = "4")]
        pub enabled: bool,
        #[prost(uint32, tag = "5")]
        pub cycle_used: u32,
        #[prost(uint32, optional, tag = "6")]
        pub cycle_limit: ::core::option::Option<u32>,
        #[prost(uint64, tag = "7")]
        pub cursor_entity_id: u64,
        #[prost(uint32, tag = "8")]
        pub cursor_usage_value: u32,
        #[prost(message, repeated, tag = "9")]
        pub entities: ::prost::alloc::vec::Vec<pool::Entity>,
        #[prost(message, optional, tag = "10")]
        pub created_at: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "11")]
        pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `Pool`.
    pub mod pool {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Entity {
            #[prost(uint64, tag = "1")]
            pub id: u64,
            #[prost(uint64, tag = "2")]
            pub invite_link_pool_id: u64,
            #[prost(uint32, tag = "3")]
            pub distributor_id: u32,
            #[prost(uint32, optional, tag = "4")]
            pub usage_limit: ::core::option::Option<u32>,
            #[prost(message, repeated, tag = "5")]
            pub logs: ::prost::alloc::vec::Vec<entity::Log>,
        }
        /// Nested message and enum types in `Entity`.
        pub mod entity {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Log {
                #[prost(uint64, tag = "1")]
                pub id: u64,
                #[prost(uint64, tag = "2")]
                pub invite_link_pool_entity_id: u64,
                #[prost(uint32, tag = "3")]
                pub cycle_id: u32,
                #[prost(uint32, tag = "4")]
                pub usage_id: u32,
                #[prost(uint32, tag = "5")]
                pub distributor_id: u32,
                #[prost(message, optional, tag = "6")]
                pub created_at: ::core::option::Option<::prost_types::Timestamp>,
            }
        }
    }
    /// Тип реферальной ссылки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        /// Персональная: всегда ведет к дистрибьютору, связанному с аккаунтом-владельцем.
        Distributor = 1,
        /// Коллективная: использует внутреннюю логику (определяемую политикой) для определения конечного дистрибьютора.
        Pool = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KIND_UNSPECIFIED",
                Self::Distributor => "KIND_DISTRIBUTOR",
                Self::Pool => "KIND_POOL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "KIND_DISTRIBUTOR" => Some(Self::Distributor),
                "KIND_POOL" => Some(Self::Pool),
                _ => None,
            }
        }
    }
    /// Статус жизненного цикла ссылки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Активна и может быть использована для регистрации.
        Active = 1,
        /// Неактивна и не может быть использована.
        Inactive = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Active => "STATUS_ACTIVE",
                Self::Inactive => "STATUS_INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_ACTIVE" => Some(Self::Active),
                "STATUS_INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// SlotPolicy определяет набор правил для группы слотов.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotPolicy`.
pub mod slot_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotPolicy>,
    }
}
/// Slot представляет собой ячейку или позицию в иерархической структуре (Tree).
/// Каждый слот принадлежит определенному дистрибьютору (Distributor).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Slot {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего слота
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Порядковый идентификатор слота в рамках вышестоящего слота (parent_id)
    #[prost(uint32, tag = "3")]
    pub parent_entity_id: u32,
    /// Числовой идентификатор ветки от вышестоящего слота (parent_id)
    #[prost(uint32, tag = "4")]
    pub parent_branch_number: u32,
    /// ID дерева, к которому относится слот
    #[prost(uint32, tag = "5")]
    pub tree_id: u32,
    /// Порядковый идентификатор слота в рамках дерева (tree_id)
    #[prost(uint32, tag = "6")]
    pub tree_entity_id: u32,
    /// ID дистрибьютора, владеющего слотом
    #[prost(uint32, tag = "7")]
    pub distributor_id: u32,
    /// Порядковый идентификатор слота в рамках дистрибьютора (distributor_id)
    #[prost(uint32, tag = "8")]
    pub distributor_entity_id: u32,
    /// Порядковый идентификатор слота в рамках пары (tree_id и distributor_id)
    #[prost(uint32, tag = "9")]
    pub tree_distributor_entity_id: u32,
    /// ID партиции, к которому относится слот
    #[prost(uint32, tag = "10")]
    pub tree_partition_id: u32,
    /// Глобальный уровень глубины
    #[prost(uint32, tag = "11")]
    pub level: u32,
    /// Количество дочерних слотов
    #[prost(uint32, tag = "12")]
    pub children_quantity: u32,
    /// Вместимость дочерних слотов
    #[prost(uint32, tag = "13")]
    pub children_capacity: u32,
    /// Количество слотов в структуре
    #[prost(uint32, tag = "14")]
    pub structure_quantity: u32,
    /// Вместимость слотов в структуре
    #[prost(uint64, tag = "15")]
    pub structure_capacity: u64,
    /// Последний ID слота в структуре
    #[prost(uint32, tag = "16")]
    pub structure_last_id: u32,
    /// Максимальный уровень слота в структуре
    #[prost(uint32, tag = "17")]
    pub structure_level_max: u32,
    #[prost(uint64, tag = "18")]
    pub trace_id: u64,
    /// ID политики, применяемой к этому слоту.
    #[prost(uint32, tag = "19")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "20")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "21")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "22")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Slot`.
pub mod slot {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации слота
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3, 4, 5, 6")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentBranch {
            /// ID вышестоящего слота
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Числовой идентификатор ветки от вышестоящего слота (parent_id)
            #[prost(uint32, tag = "2")]
            pub parent_branch_number: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentEntity {
            /// ID вышестоящего слота
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Порядковый идентификатор слота в рамках вышестоящего слота (parent_id)
            #[prost(uint32, tag = "2")]
            pub parent_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeEntity {
            /// ID дерева, к которому относится слот
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Порядковый идентификатор слота в рамках дерева (tree_id)
            #[prost(uint32, tag = "2")]
            pub tree_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DistributorEntity {
            /// ID дистрибьютора, владеющего слотом
            #[prost(uint32, tag = "1")]
            pub distributor_id: u32,
            /// Порядковый идентификатор слота в рамках дистрибьютора (distributor_id)
            #[prost(uint32, tag = "2")]
            pub distributor_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeDistributorEntity {
            /// ID дерева, к которому относится слот
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// ID дистрибьютора, владеющего слотом
            #[prost(uint32, tag = "2")]
            pub distributor_id: u32,
            /// Порядковый идентификатор слота в рамках пары (tree_id и distributor_id)
            #[prost(uint32, tag = "3")]
            pub tree_distributor_entity_id: u32,
        }
        /// Различные способы идентификации слота
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID слота
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по вышестоящему слоту и номеру ветки
            #[prost(message, tag = "2")]
            ParentBranch(ParentBranch),
            /// Идентификация слота через комбинацию ID вышестоящего слота и порядкового идентификатора слота в рамках вышестоящего слота
            #[prost(message, tag = "3")]
            ParentEntity(ParentEntity),
            /// Идентификация слота через комбинацию ID дерева и порядкового идентификатора слота в рамках этого дерева
            #[prost(message, tag = "4")]
            TreeEntity(TreeEntity),
            /// Идентификация слота через комбинацию ID дистрибьютора и порядкового идентификатора слота в рамках этого дистрибьютора
            #[prost(message, tag = "5")]
            DistributorEntity(DistributorEntity),
            /// Идентификация слота через комбинацию ID дерева, ID дистрибьютора и порядкового идентификатора слота в рамках этой пары
            #[prost(message, tag = "6")]
            TreeDistributorEntity(TreeDistributorEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Slot>,
    }
}
/// SlotBranchPolicy определяет набор правил для группы веток слотов.
/// Конкретная логика политики (например, начисление особых бонусов) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotBranchPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotBranchPolicy`.
pub mod slot_branch_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotBranchPolicy>,
    }
}
/// SlotBranch представляет собой иерархическую связь или "ветку" между слотами.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotBranch {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего слота
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Числовой идентификатор ветки от вышестоящего слота
    #[prost(uint32, tag = "3")]
    pub parent_branch_number: u32,
    /// ID дочернего слота, если ветка занята
    #[prost(uint32, optional, tag = "4")]
    pub child_id: ::core::option::Option<u32>,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, управляющая поведением ветки (например, начисление бонусов).
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotBranch`.
pub mod slot_branch {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID ветки слота
            #[prost(uint32, tag = "1")]
            Id(u32),
            #[prost(message, tag = "2")]
            ParentBranch(super::super::slot::id::ParentBranch),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotBranch>,
    }
}
/// Sort определяет порядок и количество записей в запросах на получение списков.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Sort {
    /// Направление сортировки.
    #[prost(enumeration = "sort::Direction", tag = "1")]
    pub direction: i32,
    /// Лимит записей (например, для пагинации).
    #[prost(uint32, tag = "2")]
    pub limit: u32,
}
/// Nested message and enum types in `Sort`.
pub mod sort {
    /// Направление сортировки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        /// Направление не указано. Поведение по умолчанию (обычно BACKWARD) определяется на бэкенде.
        Unspecified = 0,
        /// Прямой порядок (от старых к новым, от меньшего ID к большему).
        Forward = 1,
        /// Обратный порядок (от новых к старым, от большего ID к меньшему).
        Backward = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Forward => "FORWARD",
                Self::Backward => "BACKWARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "FORWARD" => Some(Self::Forward),
                "BACKWARD" => Some(Self::Backward),
                _ => None,
            }
        }
    }
}
/// Subject представляет собой субъект или объект, над которым было совершено действие.
/// Это типобезопасный указатель на любую ключевую сущность в системе.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Subject {
    #[prost(oneof = "subject::Entity", tags = "1, 2, 3")]
    pub entity: ::core::option::Option<subject::Entity>,
}
/// Nested message and enum types in `Subject`.
pub mod subject {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Entity {
        #[prost(uint32, tag = "1")]
        AccountId(u32),
        #[prost(uint32, tag = "2")]
        CurrencyId(u32),
        /// ... и другие важные сущности могут быть добавлены в будущем
        #[prost(uint32, tag = "3")]
        BonusId(u32),
    }
}
/// Trace представляет собой полную трассировку одной бизнес-операции, состоящую из плоского списка шагов (spans).
/// Иерархия шагов строится на клиенте с использованием поля `parent_id`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    /// Глобальный УНИКАЛЬНЫЙ ID всей бизнес-операции.
    #[prost(uint64, tag = "1")]
    pub trace_id: u64,
    /// Аккаунт, который ИНИЦИИРОВАЛ всю операцию. Если пуст - действие системное.
    #[prost(uint32, optional, tag = "2")]
    pub actor_id: ::core::option::Option<u32>,
    /// Плоский список всех шагов, произошедших в рамках этой операции.
    #[prost(message, repeated, tag = "3")]
    pub spans: ::prost::alloc::vec::Vec<trace::Span>,
}
/// Nested message and enum types in `Trace`.
pub mod trace {
    /// Span представляет один, конкретный, атомарный шаг (операцию) в трассировке.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Span {
        /// Уникальный ID самого шага (span'а).
        #[prost(uint64, tag = "1")]
        pub id: u64,
        /// ID родительского шага. Равен 0 для корневого шага.
        #[prost(uint64, tag = "2")]
        pub parent_id: u64,
        /// Техническое имя операции (например, "CreateLedgerTransaction").
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        /// Статус выполнения этого шага.
        #[prost(enumeration = "span::Status", tag = "4")]
        pub status: i32,
        /// Сообщение об ошибке, если status = FAILURE.
        #[prost(string, optional, tag = "5")]
        pub error_message: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "6")]
        pub started_at: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "7")]
        pub finished_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Контекст, специфичный для этого шага (например, ID созданной транзакции, сумма и т.д.).
        #[prost(message, optional, tag = "8")]
        pub context: ::core::option::Option<::prost_types::Any>,
    }
    /// Nested message and enum types in `Span`.
    pub mod span {
        /// Статус выполнения шага.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            Unspecified = 0,
            /// Шаг успешно выполнен.
            Success = 1,
            /// В процессе выполнения шага произошла ошибка.
            Failure = 2,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Success => "SUCCESS",
                    Self::Failure => "FAILURE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "SUCCESS" => Some(Self::Success),
                    "FAILURE" => Some(Self::Failure),
                    _ => None,
                }
            }
        }
    }
}
/// TreePolicy определяет набор правил для группы деревьев.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreePolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePolicy`.
pub mod tree_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePolicy>,
    }
}
/// Tree представляет собой основную иерархическую структуру или сеть.
/// Она служит контейнером для слотов, дистрибьюторов и партиций.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Tree {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное строковое имя для идентификации дерева
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ID сети, к которой принадлежит дерево
    #[prost(uint32, tag = "3")]
    pub network_id: u32,
    /// Порядковый идентификатор дерева в рамках сети (network_id)
    #[prost(uint32, tag = "4")]
    pub network_entity_id: u32,
    /// ID корневой партиции (TreePartition) для данного дерева
    #[prost(uint32, tag = "5")]
    pub root_partition_id: u32,
    /// Вместимость дочерних слотов по умолчанию. Используется для визуализации структуры.
    #[prost(uint32, tag = "6")]
    pub slot_children_capacity_default: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    /// Политика, управляющая поведением всего дерева.
    #[prost(uint32, tag = "8")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Tree`.
pub mod tree {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации дерева
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по сети и порядковому номеру
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkEntity {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор дерева в рамках сети
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        /// Различные способы идентификации дерева
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID дерева
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя дерева
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
            /// Идентификация по сети и порядковому номеру
            #[prost(message, tag = "3")]
            NetworkEntity(NetworkEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Tree>,
    }
}
/// TreeDistributorPolicy определяет набор правил для группы связей TreeDistributor.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreeDistributorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreeDistributorPolicy`.
pub mod tree_distributor_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreeDistributorPolicy>,
    }
}
/// TreeDistributor представляет собой связь между деревом (Tree) и дистрибьютором (Distributor).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreeDistributor {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Идентификатор дерева
    #[prost(uint32, tag = "2")]
    pub tree_id: u32,
    /// Порядковый номер связи в рамках дерева (tree_id)
    #[prost(uint32, tag = "3")]
    pub tree_entity_id: u32,
    /// Идентификатор дистрибьютора
    #[prost(uint32, tag = "4")]
    pub distributor_id: u32,
    /// Порядковый номер связи в рамках дистрибьютора (distributor_id)
    #[prost(uint32, tag = "5")]
    pub distributor_entity_id: u32,
    /// ID политики, применяемой к этой связи. Определяет ее статус и правила.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreeDistributor`.
pub mod tree_distributor {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации связи
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Составной идентификатор для связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Pair {
            /// Идентификатор дерева
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Идентификатор дистрибьютора
            #[prost(uint32, tag = "2")]
            pub distributor_id: u32,
        }
        /// Различные способы идентификации связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID связи
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по паре дерево-дистрибьютор
            #[prost(message, tag = "2")]
            Pair(Pair),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreeDistributor>,
    }
}
/// TreePartitionPolicy определяет набор правил для группы партиций дерева.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreePartitionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Определяет, могут ли партиции, подчиненные этой политике, быть слиты с другими. false - аналог "Standalone".
    #[prost(bool, tag = "4")]
    pub is_mergeable: bool,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePartitionPolicy`.
pub mod tree_partition_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePartitionPolicy>,
    }
}
/// TreePartition представляет собой выделенную часть или "партицию" внутри дерева (Tree).
/// Партиция начинается с определенного корневого слота и может функционировать как отдельное поддерево.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreePartition {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID родительского дерева
    #[prost(uint32, tag = "2")]
    pub tree_id: u32,
    /// Порядковый номер партиции в рамках дерева
    #[prost(uint32, tag = "3")]
    pub tree_entity_id: u32,
    /// ID корневого слота, с которого начинается партиция
    #[prost(uint32, tag = "4")]
    pub root_slot_id: u32,
    /// Политика, управляющая поведением партиции (например, возможностью слияния).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    /// Флаг, указывающий, что партиция была слита с другой и больше не активна.
    #[prost(bool, tag = "6")]
    pub is_archived: bool,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePartition`.
pub mod tree_partition {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации партиции
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по порядковому номеру в дереве
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeEntity {
            /// Идентификатор дерева
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Порядковый идентификатор партиции в рамках дерева
            #[prost(uint32, tag = "2")]
            pub tree_entity_id: u32,
        }
        /// Различные способы идентификации партиции
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID партиции
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по дереву и порядковому номеру
            #[prost(message, tag = "2")]
            Entity(TreeEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePartition>,
    }
}
/// PaymentDetails представляет собой универсальную структуру для хранения
/// одного экземпляра платежных реквизитов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentDetails {
    /// Уникальный ID реквизита в реестре пользователя.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Пользовательское название реквизита (например, "Мой основной кошелек").
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Тип реквизитов.
    #[prost(enumeration = "payment_details::kind::Id", tag = "3")]
    pub kind: i32,
    /// Статус реквизита (активен/архивирован).
    #[prost(enumeration = "payment_details::status::Id", tag = "4")]
    pub status: i32,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Конкретные данные, зависящие от типа.
    #[prost(oneof = "payment_details::Details", tags = "5")]
    pub details: ::core::option::Option<payment_details::Details>,
}
/// Nested message and enum types in `PaymentDetails`.
pub mod payment_details {
    /// Пространство имен для типа платежных реквизитов.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Kind {}
    /// Nested message and enum types in `Kind`.
    pub mod kind {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Криптовалютный кошелек.
            CryptoWallet = 1,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::CryptoWallet => "CRYPTO_WALLET",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "CRYPTO_WALLET" => Some(Self::CryptoWallet),
                    _ => None,
                }
            }
        }
    }
    /// Пространство имен для статуса жизненного цикла реквизита.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Реквизит активен и отображается в списках.
            Active = 1,
            /// Реквизит архивирован, не отображается в общих списках,
            /// но доступен по прямому идентификатору.
            Archived = 2,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Archived => "ARCHIVED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "ARCHIVED" => Some(Self::Archived),
                    _ => None,
                }
            }
        }
    }
    /// Реквизиты криптовалютного кошелька.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CryptoWallet {
        /// Тип сети.
        #[prost(enumeration = "crypto_wallet::NetworkType", tag = "1")]
        pub network_type: i32,
        /// Адрес кошелька.
        #[prost(string, tag = "2")]
        pub address: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `CryptoWallet`.
    pub mod crypto_wallet {
        /// Тип сети кошелька.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum NetworkType {
            Unspecified = 0,
            /// Адрес, совместимый с EVM (Ethereum, BNB Chain и т.д.).
            EvmHex = 1,
        }
        impl NetworkType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::EvmHex => "EVM_HEX",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "EVM_HEX" => Some(Self::EvmHex),
                    _ => None,
                }
            }
        }
    }
    /// Конкретные данные, зависящие от типа.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag = "5")]
        CryptoWallet(CryptoWallet),
    }
}
/// PaymentDetailsRegistry представляет собой реестр (белый список) платежных
/// реквизитов, сохраненных пользователем, вместе с лимитами.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentDetailsRegistry {
    /// Список сохраненных платежных реквизитов.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<PaymentDetails>,
    /// Лимиты на количество записей.
    #[prost(message, optional, tag = "2")]
    pub limit: ::core::option::Option<payment_details_registry::Limit>,
}
/// Nested message and enum types in `PaymentDetailsRegistry`.
pub mod payment_details_registry {
    /// Лимиты на количество записей в реестре.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Limit {
        /// Общий лимит на количество записей в реестре.
        #[prost(uint32, optional, tag = "1")]
        pub total: ::core::option::Option<u32>,
        /// Лимиты для каждого типа реквизитов.
        #[prost(message, repeated, tag = "2")]
        pub per_type: ::prost::alloc::vec::Vec<limit::PerType>,
    }
    /// Nested message and enum types in `Limit`.
    pub mod limit {
        /// Лимит для конкретного типа реквизитов.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PerType {
            /// Тип реквизитов.
            #[prost(message, optional, tag = "1")]
            pub kind: ::core::option::Option<super::super::payment_details::Kind>,
            /// Максимальное количество записей этого типа.
            #[prost(uint32, tag = "2")]
            pub value: u32,
        }
    }
}
