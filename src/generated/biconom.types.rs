// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Presence {
    #[prost(enumeration = "presence::Status", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `Presence`.
pub mod presence {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Пользователь онлайн прямо сейчас (менее 30 секунд назад)
        Online = 1,
        /// Был в сети недавно (от 30 секунд до 3 минут назад)
        Recently = 2,
        /// Был в сети в течение последнего часа (до 1 часа назад)
        LastHour = 3,
        /// Был в сети в течение сегодняшнего дня (до 24 часов назад)
        Today = 4,
        /// Был в сети в последние 3 дня
        LastFewDays = 5,
        /// Был в сети в течение последней недели
        LastWeek = 6,
        /// Был в сети давно (более недели)
        LongTimeAgo = 7,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Online => "ONLINE",
                Self::Recently => "RECENTLY",
                Self::LastHour => "LAST_HOUR",
                Self::Today => "TODAY",
                Self::LastFewDays => "LAST_FEW_DAYS",
                Self::LastWeek => "LAST_WEEK",
                Self::LongTimeAgo => "LONG_TIME_AGO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ONLINE" => Some(Self::Online),
                "RECENTLY" => Some(Self::Recently),
                "LAST_HOUR" => Some(Self::LastHour),
                "TODAY" => Some(Self::Today),
                "LAST_FEW_DAYS" => Some(Self::LastFewDays),
                "LAST_WEEK" => Some(Self::LastWeek),
                "LONG_TIME_AGO" => Some(Self::LongTimeAgo),
                _ => None,
            }
        }
    }
}
/// Модель данных для пользователя системы
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct User {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(enumeration = "presence::Status", tag = "2")]
    pub presence_status: i32,
    /// Политика, управляющая поведением пользователя.
    #[prost(uint32, tag = "3")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `User`.
pub mod user {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID пользователя
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// Элементы списка (пользователи)
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::User>,
    }
}
/// Модель данных для сообществ системы
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Community {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "community::Status", tag = "3")]
    pub status: i32,
    /// Политика, управляющая поведением сообщества.
    #[prost(uint32, tag = "4")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Community`.
pub mod community {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID сообщества
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное название сообщества
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    /// Список сообществ
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// Элементы списка (сообщества)
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Community>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Сообщество активно
        Active = 1,
        /// Временно заблокировано (например, нарушено правило)
        Suspended = 2,
        /// Архивировано, не допускает изменений и новых участников
        Archived = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Suspended => "SUSPENDED",
                Self::Archived => "ARCHIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "SUSPENDED" => Some(Self::Suspended),
                "ARCHIVED" => Some(Self::Archived),
                _ => None,
            }
        }
    }
}
/// Account является универсальной учетной записью в системе.
/// Он представляет собой абстракцию, которая может ссылаться либо на пользователя (User),
/// либо на сообщество (Community), позволяя им выступать в роли владельцев других сущностей.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Account {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Политика, управляющая поведением аккаунта (включая права доступа).
    #[prost(uint32, tag = "4")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Тип владельца аккаунта
    #[prost(oneof = "account::Owner", tags = "2, 3")]
    pub owner: ::core::option::Option<account::Owner>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Уникальный ID аккаунта
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный ID пользователя
            #[prost(uint32, tag = "2")]
            UserId(u32),
            /// Уникальный ID сообщества
            #[prost(uint32, tag = "3")]
            CommunityId(u32),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Account>,
    }
    /// Тип владельца аккаунта
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Owner {
        /// Ссылка на пользователя
        #[prost(message, tag = "2")]
        User(super::User),
        /// Ссылка на сообщество
        #[prost(message, tag = "3")]
        Community(super::Community),
    }
}
/// Asset представляет собой любой тип актива, который может быть учтен на счете (Ledger).
/// Это может быть как финансовая единица, так и инвентарный объект.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Asset {
    #[prost(oneof = "asset::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<asset::Kind>,
}
/// Nested message and enum types in `Asset`.
pub mod asset {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Kind {
        /// ID валюты.
        #[prost(uint32, tag = "1")]
        CurrencyId(u32),
        /// ID инвентарной единицы (для будущего использования).
        #[prost(uint64, tag = "2")]
        InventoryId(u64),
    }
}
/// AccountPolicy определяет набор правил для группы аккаунтов.
/// Конкретная логика политики (например, блокировка всех операций) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `AccountPolicy`.
pub mod account_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::AccountPolicy>,
    }
}
/// Bonus представляет собой справочную информацию о бонусе, существующем в системе.
/// Вся логика его расчета и начисления определяется в связанной BonusPolicy.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Bonus {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя бонуса (например, "Реферальный бонус")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Заголовок для отображения пользователю
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    /// Описание для отображения пользователю
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, определяющая правила расчета и начисления бонуса.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Bonus`.
pub mod bonus {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID бонуса
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя бонуса
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Bonus>,
    }
}
/// BonusPolicy определяет набор правил для группы бонусов.
/// Конкретная логика расчета и начисления бонуса реализуется на бэкенде
/// и привязывается к этой политике по ее имени или ID.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BonusPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `BonusPolicy`.
pub mod bonus_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::BonusPolicy>,
    }
}
/// Boundary определяет граничное значение и его тип (включительно или исключительно).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Boundary {
    /// Значение границы (например, "1000").
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    /// Тип границы (включительно/исключительно).
    #[prost(enumeration = "boundary::Kind", tag = "2")]
    pub kind: i32,
}
/// Nested message and enum types in `Boundary`.
pub mod boundary {
    /// Определяет, включается ли граничное значение в диапазон.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        /// Тип не указан.
        Unspecified = 0,
        /// Включительно (>= или \<=).
        Inclusive = 1,
        /// Исключительно (> или \<).
        Exclusive = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Inclusive => "INCLUSIVE",
                Self::Exclusive => "EXCLUSIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUSIVE" => Some(Self::Inclusive),
                "EXCLUSIVE" => Some(Self::Exclusive),
                _ => None,
            }
        }
    }
}
/// Rounding определяет полные правила математического округления.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rounding {
    /// Количество знаков для округления. Положительное - после запятой, отрицательное - до запятой.
    #[prost(sint32, tag = "1")]
    pub digits: i32,
    /// Стратегия округления.
    #[prost(enumeration = "rounding::Strategy", tag = "2")]
    pub strategy: i32,
}
/// Nested message and enum types in `Rounding`.
pub mod rounding {
    /// Определяет математическую стратегию округления.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Strategy {
        /// Режим не указан. Будет использована стратегия по умолчанию (TO_ZERO).
        Unspecified = 0,
        /// Округление к ближайшему чётному. Также известно как "Банковское округление".
        /// Например, 6.5 -> 6, 7.5 -> 8.
        MidpointNearestEven = 1,
        /// Округление половины к числу, которое дальше от нуля.
        /// Например, 6.4 -> 6, 6.5 -> 7, -6.5 -> -7.
        MidpointAwayFromZero = 2,
        /// Округление половины к числу, которое ближе к нулю.
        /// Например, 6.4 -> 6, 6.5 -> 6, -6.5 -> -6.
        MidpointTowardZero = 3,
        /// Округление всегда к нулю.
        /// Например, -6.8 -> -6, 6.8 -> 6.
        ToZero = 4,
        /// Округление всегда от нуля.
        /// Например, -6.8 -> -7, 6.8 -> 7.
        AwayFromZero = 5,
        /// Округление всегда к минус бесконечности.
        /// Например, 6.8 -> 6, -6.8 -> -7.
        ToNegativeInfinity = 6,
        /// Округление всегда к плюс бесконечности.
        /// Например, 6.8 -> 7, -6.8 -> -6.
        ToPositiveInfinity = 7,
    }
    impl Strategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::MidpointNearestEven => "MIDPOINT_NEAREST_EVEN",
                Self::MidpointAwayFromZero => "MIDPOINT_AWAY_FROM_ZERO",
                Self::MidpointTowardZero => "MIDPOINT_TOWARD_ZERO",
                Self::ToZero => "TO_ZERO",
                Self::AwayFromZero => "AWAY_FROM_ZERO",
                Self::ToNegativeInfinity => "TO_NEGATIVE_INFINITY",
                Self::ToPositiveInfinity => "TO_POSITIVE_INFINITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "MIDPOINT_NEAREST_EVEN" => Some(Self::MidpointNearestEven),
                "MIDPOINT_AWAY_FROM_ZERO" => Some(Self::MidpointAwayFromZero),
                "MIDPOINT_TOWARD_ZERO" => Some(Self::MidpointTowardZero),
                "TO_ZERO" => Some(Self::ToZero),
                "AWAY_FROM_ZERO" => Some(Self::AwayFromZero),
                "TO_NEGATIVE_INFINITY" => Some(Self::ToNegativeInfinity),
                "TO_POSITIVE_INFINITY" => Some(Self::ToPositiveInfinity),
                _ => None,
            }
        }
    }
}
/// Calculation является инструкцией для динамического расчета суммы.
/// Это не самостоятельная сущность, а встраиваемая модель для описания правил.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Calculation {
    /// Правила постобработки, применяемые к результату.
    #[prost(message, optional, tag = "4")]
    pub post_processing: ::core::option::Option<calculation::PostProcessing>,
    /// Определяет вид/структуру калькуляции.
    #[prost(oneof = "calculation::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<calculation::Kind>,
}
/// Nested message and enum types in `Calculation`.
pub mod calculation {
    /// Simple описывает простой, линейный расчет.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Simple {
        /// Фиксированная часть (например, "5.00" USDT).
        #[prost(string, tag = "1")]
        pub fixed_value: ::prost::alloc::string::String,
        /// Процентная часть (например, "0.01" для 1%).
        #[prost(string, tag = "2")]
        pub percent_value: ::prost::alloc::string::String,
    }
    /// Tiered описывает многоуровневый расчет.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tiered {
        #[prost(enumeration = "tiered::Mode", tag = "1")]
        pub mode: i32,
        #[prost(message, repeated, tag = "2")]
        pub tiers: ::prost::alloc::vec::Vec<tiered::Tier>,
    }
    /// Nested message and enum types in `Tiered`.
    pub mod tiered {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Tier {
            #[prost(message, optional, tag = "1")]
            pub lower_bound: ::core::option::Option<super::super::Boundary>,
            #[prost(message, optional, tag = "2")]
            pub upper_bound: ::core::option::Option<super::super::Boundary>,
            #[prost(message, optional, tag = "3")]
            pub calculation: ::core::option::Option<super::Simple>,
        }
        /// Определяет, как применяется расчет в многоуровневой шкале.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            /// По достижению.
            Slab = 1,
            /// Прогрессивная.
            Progressive = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Slab => "SLAB",
                    Self::Progressive => "PROGRESSIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "SLAB" => Some(Self::Slab),
                    "PROGRESSIVE" => Some(Self::Progressive),
                    _ => None,
                }
            }
        }
    }
    /// Conditional позволяет реализовать логику "if-else".
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Conditional {
        #[prost(message, optional, tag = "1")]
        pub condition: ::core::option::Option<super::Boundary>,
        #[prost(message, optional, boxed, tag = "2")]
        pub if_true: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::Calculation>,
        >,
        #[prost(message, optional, boxed, tag = "3")]
        pub if_false: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::Calculation>,
        >,
    }
    /// PostProcessing определяет правила, применяемые к результату расчета.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PostProcessing {
        /// Минимальное значение результата (например, "комиссия не менее 10").
        #[prost(string, optional, tag = "1")]
        pub min_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Максимальное значение результата (например, "комиссия не более 100").
        #[prost(string, optional, tag = "2")]
        pub max_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Правила округления.
        #[prost(message, optional, tag = "3")]
        pub rounding: ::core::option::Option<super::Rounding>,
    }
    /// Определяет вид/структуру калькуляции.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Simple(Simple),
        #[prost(message, tag = "2")]
        Tiered(Tiered),
        #[prost(message, tag = "3")]
        Conditional(::prost::alloc::boxed::Box<Conditional>),
    }
}
/// CalculationGroup - это контейнер для нескольких независимых расчетов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationGroup {
    #[prost(map = "string, message", tag = "1")]
    pub calculations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Calculation,
    >,
}
/// CommunityPolicy определяет набор правил для группы сообществ.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CommunityPolicy`.
pub mod community_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CommunityPolicy>,
    }
}
/// TransactionGroup - это контейнер верхнего уровня, объединяющий одну или несколько транзакций,
/// которые относятся к одной бизнес-операции.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionGroup {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(message, optional, tag = "2")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Список транзакций, входящих в эту группу.
    #[prost(message, repeated, tag = "3")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
}
/// Nested message and enum types in `TransactionGroup`.
pub mod transaction_group {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TransactionGroup>,
    }
}
/// Transaction представляет собой логическую финансовую операцию над одним активом.
/// Она состоит из одной или нескольких бухгалтерских проводок (TransactionEntry).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// Уникальный ID транзакции.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// ID группы, к которой принадлежит транзакция.
    #[prost(uint64, tag = "2")]
    pub group_id: u64,
    /// ID родительской транзакции (для сторнирования или связанных операций).
    #[prost(uint64, optional, tag = "3")]
    pub parent_transaction_id: ::core::option::Option<u64>,
    /// Актив, с которым работает транзакция.
    #[prost(message, optional, tag = "4")]
    pub asset: ::core::option::Option<Asset>,
    /// Слой исполнения.
    #[prost(enumeration = "transaction::layer::Id", tag = "5")]
    pub layer: i32,
    /// Текущий статус.
    #[prost(enumeration = "transaction::status::Id", tag = "6")]
    pub status: i32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Список проводок, составляющих эту транзакцию.
    #[prost(message, repeated, tag = "9")]
    pub entries: ::prost::alloc::vec::Vec<TransactionEntry>,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Transaction>,
    }
    /// Слой, на котором выполняется транзакция.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Layer {}
    /// Nested message and enum types in `Layer`.
    pub mod layer {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Основной слой, немедленное исполнение.
            Primary = 1,
            /// Запланированная операция, которая будет исполнена в будущем.
            Scheduled = 2,
            /// Платежный слой, связанный с внешними системами.
            Payment = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Primary => "PRIMARY",
                    Self::Scheduled => "SCHEDULED",
                    Self::Payment => "PAYMENT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "PRIMARY" => Some(Self::Primary),
                    "SCHEDULED" => Some(Self::Scheduled),
                    "PAYMENT" => Some(Self::Payment),
                    _ => None,
                }
            }
        }
    }
    /// Статус жизненного цикла транзакции.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Операция инициирована, но еще не отражена на счетах.
            Pending = 1,
            /// Сумма зарезервирована (например, предавторизация по карте).
            Authorized = 2,
            /// Проводка отражена в книге (баланс изменен).
            Posted = 3,
            /// Аннулирована до отражения (проводки не было).
            Voided = 4,
            /// Отклонена системой (ошибка, лимит, несоответствие).
            Rejected = 5,
            /// Сторнирована (была проведена и затем отменена обратной записью).
            Reversed = 6,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Pending => "PENDING",
                    Self::Authorized => "AUTHORIZED",
                    Self::Posted => "POSTED",
                    Self::Voided => "VOIDED",
                    Self::Rejected => "REJECTED",
                    Self::Reversed => "REVERSED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "PENDING" => Some(Self::Pending),
                    "AUTHORIZED" => Some(Self::Authorized),
                    "POSTED" => Some(Self::Posted),
                    "VOIDED" => Some(Self::Voided),
                    "REJECTED" => Some(Self::Rejected),
                    "REVERSED" => Some(Self::Reversed),
                    _ => None,
                }
            }
        }
    }
}
/// TransactionEntry представляет собой одну бухгалтерскую проводку (дебет или кредит)
/// по одному счету Ledger. Является дочерним элементом Transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransactionEntry {
    /// Уникальный ID проводки.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// ID родительской транзакции.
    #[prost(uint64, tag = "2")]
    pub transaction_id: u64,
    /// ID счета, по которому выполняется проводка.
    #[prost(uint64, tag = "3")]
    pub ledger_id: u64,
    /// Направление (дебет/кредит).
    #[prost(enumeration = "transaction_entry::direction::Id", tag = "4")]
    pub direction: i32,
    /// Сумма проводки в виде строки для высокой точности.
    #[prost(string, tag = "5")]
    pub amount: ::prost::alloc::string::String,
    /// Причина проводки.
    #[prost(message, optional, tag = "6")]
    pub reason: ::core::option::Option<transaction_entry::Reason>,
    /// Необязательное примечание.
    #[prost(string, optional, tag = "7")]
    pub note: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TransactionEntry`.
pub mod transaction_entry {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TransactionEntry>,
    }
    /// Направление движения средств.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Direction {}
    /// Nested message and enum types in `Direction`.
    pub mod direction {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Списание со счета.
            Debit = 1,
            /// Зачисление на счет.
            Credit = 2,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Debit => "DEBIT",
                    Self::Credit => "CREDIT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "DEBIT" => Some(Self::Debit),
                    "CREDIT" => Some(Self::Credit),
                    _ => None,
                }
            }
        }
    }
    /// Причина или контекст проводки.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Reason {
        #[prost(oneof = "reason::Kind", tags = "1")]
        pub kind: ::core::option::Option<reason::Kind>,
    }
    /// Nested message and enum types in `Reason`.
    pub mod reason {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Kind {
            /// В будущем здесь будут структурированные причины.
            /// Например: Fee, Commission, Bonus, etc.
            #[prost(string, tag = "1")]
            Json(::prost::alloc::string::String),
        }
    }
}
/// TransactionScopeId - это универсальный идентификатор, который может указывать на любую сущность
/// в иерархии транзакций (группу, транзакцию или проводку).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransactionScopeId {
    #[prost(oneof = "transaction_scope_id::Id", tags = "1, 2, 3")]
    pub id: ::core::option::Option<transaction_scope_id::Id>,
}
/// Nested message and enum types in `TransactionScopeId`.
pub mod transaction_scope_id {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Id {
        #[prost(uint64, tag = "1")]
        GroupId(u64),
        #[prost(uint64, tag = "2")]
        TransactionId(u64),
        #[prost(uint64, tag = "3")]
        EntryId(u64),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PasswordPolicy {
    /// ID политики
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Настройки политики
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<password_policy::Config>,
    /// Дата создания
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PasswordPolicy`.
pub mod password_policy {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Уникальный идентификатор политики паролей
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::PasswordPolicy>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PasswordReport {
        #[prost(bool, tag = "1")]
        pub is_valid: bool,
        #[prost(bool, tag = "2")]
        pub empty: bool,
        #[prost(bool, tag = "3")]
        pub too_short: bool,
        #[prost(bool, tag = "4")]
        pub too_long: bool,
        #[prost(bool, tag = "5")]
        pub group_satisfied: bool,
        #[prost(string, repeated, tag = "6")]
        pub forbidden: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "7")]
        pub denied: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Config {
        /// Минимально допустимая длина пароля
        #[prost(uint32, tag = "1")]
        pub min_length: u32,
        /// Максимально допустимая длина пароля
        #[prost(uint32, tag = "2")]
        pub max_length: u32,
        /// Битовая маска разрешённых классов символов.
        /// Например: (1 \<\< DIGITS) | (1 \<\< UPPERCASE) => 0b000101
        #[prost(uint32, tag = "3")]
        pub allowed_bit_mask: u32,
        /// Требуемые группы: хотя бы одна из групп должна быть полностью удовлетворена.
        /// Например: \[0b101\] означает DIGITS+UPPERCASE;
        /// \[0b101, 0b110\] означает: либо (DIGITS+UPPERCASE), либо (LOWERCASE+UPPERCASE)
        #[prost(uint32, repeated, tag = "4")]
        pub required_any_of_bit_mask: ::prost::alloc::vec::Vec<u32>,
    }
    /// Nested message and enum types in `Config`.
    pub mod config {
        /// Классы символов, используемые в паролях
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Character {
            /// Цифры: 0–9
            Digits = 0,
            /// Строчные латинские буквы: a–z
            Lowercase = 1,
            /// Заглавные латинские буквы: A–Z
            Uppercase = 2,
            /// Спецсимволы: !"#$%&'()\*+,-./:;\<=>?@\[\\\]^\_\`{|}~
            Special = 3,
            /// Эмодзи: Unicode ≥ 4 байт
            Emoji = 4,
        }
        impl Character {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Digits => "DIGITS",
                    Self::Lowercase => "LOWERCASE",
                    Self::Uppercase => "UPPERCASE",
                    Self::Special => "SPECIAL",
                    Self::Emoji => "EMOJI",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DIGITS" => Some(Self::Digits),
                    "LOWERCASE" => Some(Self::Lowercase),
                    "UPPERCASE" => Some(Self::Uppercase),
                    "SPECIAL" => Some(Self::Special),
                    "EMOJI" => Some(Self::Emoji),
                    _ => None,
                }
            }
        }
    }
}
/// === Сетевые параметры ===
/// PaymentNetworkOperationSettings инкапсулирует технические параметры, специфичные
/// для конкретного типа платежной сети (блокчейн, банк и т.д.).
/// Эта модель используется внутри PaymentOperationSettings для детализации
/// настроек ввода и вывода средств.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentNetworkOperationSettings {
    #[prost(oneof = "payment_network_operation_settings::Kind", tags = "1")]
    pub kind: ::core::option::Option<payment_network_operation_settings::Kind>,
}
/// Nested message and enum types in `PaymentNetworkOperationSettings`.
pub mod payment_network_operation_settings {
    /// === Настройки для блокчейнов ===
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Blockchain {
        /// --- Безопасность ---
        /// Количество подтверждений сети, после которого депозит считается успешным.
        /// Критически важный параметр для защиты от реорганизации блокчейна.
        #[prost(uint32, optional, tag = "1")]
        pub required_confirmations: ::core::option::Option<u32>,
        /// Альтернативный механизм определения финализации, основанный на вероятности (0..1).
        /// Используется в некоторых PoS-сетях, где нет строгих "подтверждений".
        #[prost(string, optional, tag = "2")]
        pub finality_threshold: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration = "blockchain::memo_type::Id", tag = "3")]
        pub memo_type: i32,
        #[prost(enumeration = "blockchain::address_format::Id", repeated, tag = "4")]
        pub supported_address_formats: ::prost::alloc::vec::Vec<i32>,
        #[prost(enumeration = "blockchain::contract_type::Id", repeated, tag = "5")]
        pub supported_contract_types: ::prost::alloc::vec::Vec<i32>,
        #[prost(enumeration = "blockchain::token_standard::Id", repeated, tag = "6")]
        pub supported_token_standards: ::prost::alloc::vec::Vec<i32>,
        /// --- Оптимизации ---
        /// Поддержка пакетной отправки (одна транзакция с несколькими получателями).
        #[prost(bool, tag = "7")]
        pub supports_batching: bool,
        /// Поддержка мульти-пакетной отправки (одна бизнес-операция может породить несколько транзакций).
        #[prost(bool, tag = "8")]
        pub supports_multi_batching: bool,
        /// --- Нативная валюта ---
        /// ID нативной валюты сети, которая используется для оплаты комиссий (газа).
        #[prost(uint32, tag = "9")]
        pub native_currency_id: u32,
    }
    /// Nested message and enum types in `Blockchain`.
    pub mod blockchain {
        /// --- Memo / Tag / Message ---
        /// Определяет, требуется ли для транзакций дополнительный идентификатор (Memo/Tag) и какого он типа.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MemoType {
            #[prost(enumeration = "memo_type::Id", tag = "1")]
            pub id: i32,
        }
        /// Nested message and enum types in `MemoType`.
        pub mod memo_type {
            /// Список типов Memo.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct List {
                #[prost(enumeration = "Id", repeated, tag = "1")]
                pub items: ::prost::alloc::vec::Vec<i32>,
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Id {
                Unspecified = 0,
                None = 1,
                Text = 2,
                Number = 3,
                Hash = 4,
            }
            impl Id {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::None => "NONE",
                        Self::Text => "TEXT",
                        Self::Number => "NUMBER",
                        Self::Hash => "HASH",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "NONE" => Some(Self::None),
                        "TEXT" => Some(Self::Text),
                        "NUMBER" => Some(Self::Number),
                        "HASH" => Some(Self::Hash),
                        _ => None,
                    }
                }
            }
        }
        /// --- Форматы адресов ---
        /// Список форматов адресов, которые валидны для данной сети.
        /// Позволяет проводить валидацию на стороне клиента и сервера.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AddressFormat {
            #[prost(enumeration = "address_format::Id", tag = "1")]
            pub id: i32,
        }
        /// Nested message and enum types in `AddressFormat`.
        pub mod address_format {
            /// Список форматов адресов.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct List {
                #[prost(enumeration = "Id", repeated, tag = "1")]
                pub items: ::prost::alloc::vec::Vec<i32>,
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Id {
                Unspecified = 0,
                EvmHex = 1,
                Base58 = 2,
                Bech32 = 3,
                Bech32m = 4,
                CosmosBech32 = 5,
                SubstrateSs58 = 6,
                SolanaBase58 = 7,
                CardanoBech32 = 8,
            }
            impl Id {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::EvmHex => "EVM_HEX",
                        Self::Base58 => "BASE58",
                        Self::Bech32 => "BECH32",
                        Self::Bech32m => "BECH32M",
                        Self::CosmosBech32 => "COSMOS_BECH32",
                        Self::SubstrateSs58 => "SUBSTRATE_SS58",
                        Self::SolanaBase58 => "SOLANA_BASE58",
                        Self::CardanoBech32 => "CARDANO_BECH32",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "EVM_HEX" => Some(Self::EvmHex),
                        "BASE58" => Some(Self::Base58),
                        "BECH32" => Some(Self::Bech32),
                        "BECH32M" => Some(Self::Bech32m),
                        "COSMOS_BECH32" => Some(Self::CosmosBech32),
                        "SUBSTRATE_SS58" => Some(Self::SubstrateSs58),
                        "SOLANA_BASE58" => Some(Self::SolanaBase58),
                        "CARDANO_BECH32" => Some(Self::CardanoBech32),
                        _ => None,
                    }
                }
            }
        }
        /// --- Типы контрактов / кошельков ---
        /// Список специфичных для блокчейна типов контрактов или кошельков, которые поддерживаются системой.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ContractType {
            #[prost(enumeration = "contract_type::Id", tag = "1")]
            pub id: i32,
        }
        /// Nested message and enum types in `ContractType`.
        pub mod contract_type {
            /// Список типов контрактов.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct List {
                #[prost(enumeration = "Id", repeated, tag = "1")]
                pub items: ::prost::alloc::vec::Vec<i32>,
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Id {
                Unspecified = 0,
                /// TON
                TonV3r1 = 1,
                TonV3r2 = 2,
                TonV4r2 = 3,
                TonHighload = 4,
                TonJetton = 5,
                /// EVM
                EvmErc20 = 6,
                EvmErc721 = 7,
                EvmErc1155 = 8,
                /// BTC
                BtcMultisig = 9,
            }
            impl Id {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::TonV3r1 => "TON_V3R1",
                        Self::TonV3r2 => "TON_V3R2",
                        Self::TonV4r2 => "TON_V4R2",
                        Self::TonHighload => "TON_HIGHLOAD",
                        Self::TonJetton => "TON_JETTON",
                        Self::EvmErc20 => "EVM_ERC20",
                        Self::EvmErc721 => "EVM_ERC721",
                        Self::EvmErc1155 => "EVM_ERC1155",
                        Self::BtcMultisig => "BTC_MULTISIG",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "TON_V3R1" => Some(Self::TonV3r1),
                        "TON_V3R2" => Some(Self::TonV3r2),
                        "TON_V4R2" => Some(Self::TonV4r2),
                        "TON_HIGHLOAD" => Some(Self::TonHighload),
                        "TON_JETTON" => Some(Self::TonJetton),
                        "EVM_ERC20" => Some(Self::EvmErc20),
                        "EVM_ERC721" => Some(Self::EvmErc721),
                        "EVM_ERC1155" => Some(Self::EvmErc1155),
                        "BTC_MULTISIG" => Some(Self::BtcMultisig),
                        _ => None,
                    }
                }
            }
        }
        /// --- Стандарты токенов ---
        /// Список стандартов токенов, поддерживаемых в этой сети.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TokenStandard {
            #[prost(enumeration = "token_standard::Id", tag = "1")]
            pub id: i32,
        }
        /// Nested message and enum types in `TokenStandard`.
        pub mod token_standard {
            /// Список стандартов токенов.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct List {
                #[prost(enumeration = "Id", repeated, tag = "1")]
                pub items: ::prost::alloc::vec::Vec<i32>,
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Id {
                Unspecified = 0,
                /// ERC20 и его аналоги (BEP20, TRC20 и т.д.).
                Erc20 = 1,
                Erc721 = 2,
                Erc1155 = 3,
                /// Solana Program Library (SPL).
                Spl = 4,
                /// TON Jettons.
                Jetton = 5,
                /// CosmWasm (CW20).
                Cw20 = 6,
            }
            impl Id {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::Erc20 => "ERC20",
                        Self::Erc721 => "ERC721",
                        Self::Erc1155 => "ERC1155",
                        Self::Spl => "SPL",
                        Self::Jetton => "JETTON",
                        Self::Cw20 => "CW20",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "ERC20" => Some(Self::Erc20),
                        "ERC721" => Some(Self::Erc721),
                        "ERC1155" => Some(Self::Erc1155),
                        "SPL" => Some(Self::Spl),
                        "JETTON" => Some(Self::Jetton),
                        "CW20" => Some(Self::Cw20),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Blockchain(Blockchain),
    }
}
/// PaymentInstrument представляет собой конкретные, переиспользуемые реквизиты
/// для совершения платежа (например, адрес кошелька).
/// Эта модель не содержит пользовательских или системных данных (имен, статусов),
/// а только сами реквизиты.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentInstrument {
    /// Конкретные реквизиты, зависящие от типа инструмента.
    #[prost(oneof = "payment_instrument::Details", tags = "1")]
    pub details: ::core::option::Option<payment_instrument::Details>,
}
/// Nested message and enum types in `PaymentInstrument`.
pub mod payment_instrument {
    /// Реквизиты для блокчейн-транзакции.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Blockchain {
        /// Формат адреса кошелька. Используется для валидации и фильтрации
        /// совместимых платежных сетей.
        #[prost(
            enumeration = "super::payment_network_operation_settings::blockchain::address_format::Id",
            tag = "1"
        )]
        pub address_format: i32,
        /// Адрес.
        #[prost(string, tag = "2")]
        pub address: ::prost::alloc::string::String,
    }
    /// Конкретные реквизиты, зависящие от типа инструмента.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Details {
        /// В будущем здесь могут быть BankAccount и т.д.
        #[prost(message, tag = "1")]
        Blockchain(Blockchain),
    }
}
/// PaymentDestination представляет собой запись в "адресной книге" пользователя.
/// Она хранит статичные, переиспользуемые реквизиты получателя средств (назначение платежа),
/// которые пользователь добавил в свой "белый список" для многократного использования,
/// как правило, для операций вывода.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentDestination {
    /// Реквизиты, сохраненные в этой записи. Являются естественным ключом.
    #[prost(message, optional, tag = "1")]
    pub instrument: ::core::option::Option<PaymentInstrument>,
    /// Пользовательское название (например, "Мой основной кошелек ETH").
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Статус записи. `true` - активна, `false` - архивирована.
    #[prost(bool, tag = "3")]
    pub is_active: bool,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PaymentDestination`.
pub mod payment_destination {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::PaymentDestination>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Request {
        /// Реквизиты, сохраненные в этой записи. Являются естественным ключом.
        #[prost(message, optional, tag = "1")]
        pub instrument: ::core::option::Option<super::PaymentInstrument>,
        /// Пользовательское название (например, "Мой основной кошелек ETH").
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
}
/// PaymentNetworkCurrencyWithdrawal представляет собой заявку на вывод средств.
///
/// --- Вложенные типы ---
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentNetworkCurrencyWithdrawal {
    /// Уникальный ID заявки на вывод.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Текущий статус заявки.
    #[prost(enumeration = "payment_network_currency_withdrawal::Status", tag = "2")]
    pub status: i32,
    /// Тело заявки с деталями вывода.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<payment_network_currency_withdrawal::Body>,
    /// ID связанной транзакции, которая будет создана после успешной обработки.
    #[prost(uint64, optional, tag = "4")]
    pub transaction_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PaymentNetworkCurrencyWithdrawal`.
pub mod payment_network_currency_withdrawal {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::PaymentNetworkCurrencyWithdrawal>,
    }
    /// Body содержит основные данные заявки на вывод, которые могут быть
    /// использованы как для создания новой заявки, так и для представления существующей.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Body {
        /// ID типа кошелька, с которого осуществляется вывод.
        #[prost(uint32, tag = "1")]
        pub wallet_type_id: u32,
        /// ID платежной сети, через которую осуществляется вывод.
        #[prost(uint32, tag = "2")]
        pub payment_network_id: u32,
        /// ID валюты для вывода.
        #[prost(uint32, tag = "3")]
        pub currency_id: u32,
        /// Реквизиты для вывода.
        #[prost(message, optional, tag = "4")]
        pub instrument: ::core::option::Option<super::PaymentInstrument>,
        /// Сумма вывода.
        #[prost(string, tag = "5")]
        pub amount: ::prost::alloc::string::String,
        /// Опциональное поле Memo/Tag/Message, если оно требуется для транзакции.
        #[prost(string, optional, tag = "6")]
        pub memo: ::core::option::Option<::prost::alloc::string::String>,
        /// Флаг, указывающий, что комиссию нужно вычесть из суммы `amount`.
        /// `true`: получатель получит `amount - fee`.
        /// `false` (по умолчанию): получатель получит `amount`, а с баланса будет списано `amount + fee`.
        #[prost(bool, tag = "7")]
        pub deduct_fee_from_amount: bool,
        /// Флаг, указывающий, что реквизиты (`instrument`) нужно добавить в "белый список" (адресную книгу).
        #[prost(bool, tag = "8")]
        pub add_to_whitelist: bool,
        /// Имя для новой записи в "белом списке". Используется, только если `add_to_whitelist` = `true`.
        #[prost(string, optional, tag = "9")]
        pub new_destination_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Статус жизненного цикла заявки на вывод.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Заявка создана и ожидает подтверждения пользователя.
        PendingConfirmation = 1,
        /// Заявка подтверждена и ожидает обработки системой.
        PendingProcessing = 2,
        /// Заявка находится в процессе выполнения (транзакция отправлена в сеть).
        Processing = 3,
        /// Заявка успешно выполнена.
        Completed = 4,
        /// Заявка отклонена (например, из-за ошибки валидации, недостатка средств).
        Rejected = 5,
        /// Заявка отменена пользователем.
        Cancelled = 6,
        /// Произошла ошибка во время обработки.
        Failed = 7,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::PendingConfirmation => "PENDING_CONFIRMATION",
                Self::PendingProcessing => "PENDING_PROCESSING",
                Self::Processing => "PROCESSING",
                Self::Completed => "COMPLETED",
                Self::Rejected => "REJECTED",
                Self::Cancelled => "CANCELLED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING_CONFIRMATION" => Some(Self::PendingConfirmation),
                "PENDING_PROCESSING" => Some(Self::PendingProcessing),
                "PROCESSING" => Some(Self::Processing),
                "COMPLETED" => Some(Self::Completed),
                "REJECTED" => Some(Self::Rejected),
                "CANCELLED" => Some(Self::Cancelled),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Session представляет собой активную сессию пользователя в системе.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Session {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Текущий статус сессии.
    #[prost(enumeration = "session::Status", tag = "2")]
    pub status: i32,
    /// IP-адрес и geo данные.
    #[prost(message, optional, tag = "3")]
    pub geoip: ::core::option::Option<session::Geoip>,
    #[prost(string, optional, tag = "4")]
    pub os: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub device: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6")]
    pub browser: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "presence::Status", tag = "9")]
    pub presence_status: i32,
}
/// Nested message and enum types in `Session`.
pub mod session {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Geoip {
        /// IP-адрес, с которого была создана сессия.
        #[prost(string, tag = "1")]
        pub ip_address: ::prost::alloc::string::String,
        /// Код страны, полученное по IP.
        #[prost(string, optional, tag = "2")]
        pub country_iso: ::core::option::Option<::prost::alloc::string::String>,
        /// Название страны, полученное по IP.
        #[prost(string, optional, tag = "3")]
        pub country: ::core::option::Option<::prost::alloc::string::String>,
        /// Название города, полученное по IP.
        #[prost(string, optional, tag = "4")]
        pub city: ::core::option::Option<::prost::alloc::string::String>,
        /// Название промежуточных регионов (Штат/область), полученное по IP.
        #[prost(string, repeated, tag = "5")]
        pub subdivisions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID сессии.
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Session>,
    }
    /// Статус жизненного цикла сессии.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Сессия активна и используется.
        Active = 1,
        /// Сессия требует подтверждения (например, при входе с нового устройства).
        Pending = 2,
        /// Сессия была завершена пользователем (logout).
        Cancelled = 3,
        /// Сессия была принудительно завершена системой (например, при входе с нового устройства).
        Revoked = 4,
        /// Срок действия сессии истек (по времени или неактивности).
        Expired = 5,
        /// Принудительное завершение (система, модерация)
        Terminated = 6,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Pending => "PENDING",
                Self::Cancelled => "CANCELLED",
                Self::Revoked => "REVOKED",
                Self::Expired => "EXPIRED",
                Self::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PENDING" => Some(Self::Pending),
                "CANCELLED" => Some(Self::Cancelled),
                "REVOKED" => Some(Self::Revoked),
                "EXPIRED" => Some(Self::Expired),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
}
/// Confirmation представляет собой одноразовую форму или сессию для подтверждения важного действия.
///
/// --- Вложенные типы и сообщения ----
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Confirmation {
    #[prost(uint64, optional, tag = "1")]
    pub id: ::core::option::Option<u64>,
    /// Уникальное имя действия (например, "WITHDRAWAL").
    #[prost(string, tag = "2")]
    pub action_name: ::prost::alloc::string::String,
    #[prost(enumeration = "confirmation::Status", tag = "3")]
    pub status: i32,
    /// Лимит попыток верификации для этой формы
    #[prost(uint32, tag = "4")]
    pub verification_attempt_limit: u32,
    /// Количество сделанных попыток верификации.
    #[prost(uint32, tag = "5")]
    pub verification_attempts_made: u32,
    /// Список всех доступных полей для этой формы.
    #[prost(message, repeated, tag = "6")]
    pub fields: ::prost::alloc::vec::Vec<confirmation::Field>,
    /// Битовая маска для групп полей, которые были успешно подтверждены.
    #[prost(uint32, optional, tag = "7")]
    pub approved_group_bit_mask: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Точное время, когда форма станет недействительной (рассчитывается на основе политики).
    #[prost(message, optional, tag = "9")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Гибкое поле для дополнительных данных.
    #[prost(message, optional, tag = "11")]
    pub metadata: ::core::option::Option<confirmation::Metadata>,
}
/// Nested message and enum types in `Confirmation`.
pub mod confirmation {
    /// Описание одного поля для верификации.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Field {
        /// Уникальный ID поля в рамках формы.
        #[prost(uint32, tag = "1")]
        pub id: u32,
        /// Битовая маска для группировки полей.
        #[prost(uint32, tag = "2")]
        pub group_bit_mask: u32,
        /// Тип поля (пароль, 2FA, чекбокс и т.д.).
        #[prost(enumeration = "field::Kind", tag = "3")]
        pub kind: i32,
        #[prost(oneof = "field::Config", tags = "4, 5, 6")]
        pub config: ::core::option::Option<field::Config>,
    }
    /// Nested message and enum types in `Field`.
    pub mod field {
        /// Детали генерации кодов для каналов связи.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Chanel {
            /// Тип канала связи (email, sms и т.д.).
            #[prost(enumeration = "chanel::Kind", tag = "1")]
            pub chanel_kind: i32,
            /// Значение канала связи (например, email адрес).
            #[prost(string, tag = "2")]
            pub chanel_contact: ::prost::alloc::string::String,
            /// Интервал между попытками генерации нового кода (в секундах).
            #[prost(uint32, tag = "3")]
            pub generation_duration: u32,
            /// Время генерации последнего кода.
            #[prost(message, optional, tag = "4")]
            pub last_generated_at: ::core::option::Option<::prost_types::Timestamp>,
            /// Лимит доступных попыток генерации нового кода.
            #[prost(uint32, tag = "5")]
            pub generation_attempt_limit: u32,
            /// Количество уже сделанных попыток генерации.
            #[prost(uint32, tag = "6")]
            pub generation_attempts_made: u32,
        }
        /// Nested message and enum types in `Chanel`.
        pub mod chanel {
            /// Типы контактного канала, на который отправляется код.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Kind {
                Unspecified = 0,
                Email = 1,
            }
            impl Kind {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::Email => "EMAIL",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "EMAIL" => Some(Self::Email),
                        _ => None,
                    }
                }
            }
        }
        /// Индексы позиций в мнемонической фразе, которые нужно заполнить.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MnemonicPositions {
            /// Список позиций (1 \<= N \<= 24) в мнемонической фразе.
            #[prost(uint32, repeated, tag = "1")]
            pub positions: ::prost::alloc::vec::Vec<u32>,
        }
        /// Типы полей, которые могут потребоваться для подтверждения.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            Unspecified = 0,
            /// Код, отправленный на канал связи (например, email).
            Chanel = 1,
            /// Пароль от аккаунта пользователя.
            Password = 2,
            /// Новый пароль для аккаунта пользователя.
            PasswordNew = 3,
            /// Чекбокс для подтверждения согласия с условиями.
            Agreement = 4,
            /// Код из приложения 2FA Google Authenticator.
            GoogleAuthenticatorCode = 5,
            /// Идентификаторы позиций в мнемонической фразе (mnemonic).
            MnemonicPositions = 6,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Chanel => "CHANEL",
                    Self::Password => "PASSWORD",
                    Self::PasswordNew => "PASSWORD_NEW",
                    Self::Agreement => "AGREEMENT",
                    Self::GoogleAuthenticatorCode => "GOOGLE_AUTHENTICATOR_CODE",
                    Self::MnemonicPositions => "MNEMONIC_POSITIONS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "CHANEL" => Some(Self::Chanel),
                    "PASSWORD" => Some(Self::Password),
                    "PASSWORD_NEW" => Some(Self::PasswordNew),
                    "AGREEMENT" => Some(Self::Agreement),
                    "GOOGLE_AUTHENTICATOR_CODE" => Some(Self::GoogleAuthenticatorCode),
                    "MNEMONIC_POSITIONS" => Some(Self::MnemonicPositions),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Config {
            /// Детали генерации кода для канала связи.
            #[prost(message, tag = "4")]
            Chanel(Chanel),
            /// Детали конфигурации пароля.
            #[prost(message, tag = "5")]
            PasswordPolicyConfig(super::super::password_policy::Config),
            /// Список позиций в мнемонической фразе.
            #[prost(message, tag = "6")]
            MnemonicPositions(MnemonicPositions),
        }
    }
    /// Идентификатор для поиска формы.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID формы.
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    /// Список форм подтверждения.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Confirmation>,
    }
    /// Запрос на генерацию одноразового кода для поля.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GenerateCodeRequest {
        /// ID формы подтверждения.
        #[prost(uint64, tag = "1")]
        pub confirmation_id: u64,
        /// ID поля, для которого нужно сгенерировать код.
        #[prost(uint32, tag = "2")]
        pub field_id: u32,
    }
    /// Запрос на подтверждение формы.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Form {}
    /// Nested message and enum types in `Form`.
    pub mod form {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Request {
            /// Глобальный ID формы для подтверждения.
            #[prost(uint64, tag = "1")]
            pub confirmation_id: u64,
            /// Список полей, которые отправляет пользователь.
            #[prost(message, repeated, tag = "2")]
            pub fields: ::prost::alloc::vec::Vec<request::Field>,
        }
        /// Nested message and enum types in `Request`.
        pub mod request {
            /// Поле, предоставленное пользователем для верификации.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Field {
                /// ID поля, которое заполняет пользователь.
                #[prost(uint32, tag = "1")]
                pub field_id: u32,
                #[prost(oneof = "field::Value", tags = "2, 3")]
                pub value: ::core::option::Option<field::Value>,
            }
            /// Nested message and enum types in `Field`.
            pub mod field {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Value {
                    /// Значение для полей типа пароль, код и т.д.
                    #[prost(string, tag = "2")]
                    StringValue(::prost::alloc::string::String),
                    /// Значение для чекбокса (должно быть `true`).
                    #[prost(bool, tag = "3")]
                    BoolValue(bool),
                }
            }
        }
        /// Ответ на запрос подтверждения формы.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Response {
            /// Общий статус подтверждения.
            #[prost(enumeration = "response::Status", tag = "1")]
            pub status: i32,
            /// Детальный результат по каждому полю.
            #[prost(message, repeated, tag = "2")]
            pub fields: ::prost::alloc::vec::Vec<response::Field>,
            /// Дополнительные данные, возвращаемые при успехе.
            #[prost(message, optional, tag = "3")]
            pub metadata: ::core::option::Option<response::Metadata>,
        }
        /// Nested message and enum types in `Response`.
        pub mod response {
            /// Результат проверки для одного поля.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Field {
                /// ID проверенного поля.
                #[prost(uint32, tag = "1")]
                pub field_id: u32,
                /// Статус проверки этого поля.
                #[prost(enumeration = "field::Status", tag = "2")]
                pub status: i32,
                #[prost(oneof = "field::Details", tags = "3")]
                pub details: ::core::option::Option<field::Details>,
            }
            /// Nested message and enum types in `Field`.
            pub mod field {
                /// Детальный статус для каждого отдельного поля.
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Status {
                    Unspecified = 0,
                    /// Поле заполнено верно.
                    Ok = 1,
                    /// Поле не заполнено, но является обязательным.
                    Empty = 2,
                    /// Поле заполнено неверно.
                    Wrong = 3,
                    /// Пользователь не согласился с условиями (чекбокс не `true`).
                    NotAgreed = 4,
                    /// Ранее пароль уже использовался и не может быть повторно использован.
                    PasswordAlreadyUsed = 5,
                }
                impl Status {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "UNSPECIFIED",
                            Self::Ok => "OK",
                            Self::Empty => "EMPTY",
                            Self::Wrong => "WRONG",
                            Self::NotAgreed => "NOT_AGREED",
                            Self::PasswordAlreadyUsed => "PASSWORD_ALREADY_USED",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "UNSPECIFIED" => Some(Self::Unspecified),
                            "OK" => Some(Self::Ok),
                            "EMPTY" => Some(Self::Empty),
                            "WRONG" => Some(Self::Wrong),
                            "NOT_AGREED" => Some(Self::NotAgreed),
                            "PASSWORD_ALREADY_USED" => Some(Self::PasswordAlreadyUsed),
                            _ => None,
                        }
                    }
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Details {
                    /// Детали валидации для полей (PASSWORD | PASSWORD_NEW)
                    #[prost(message, tag = "3")]
                    PasswordReport(
                        super::super::super::super::password_policy::PasswordReport,
                    ),
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Metadata {
                #[prost(string, optional, tag = "1")]
                pub authorization_bearer: ::core::option::Option<
                    ::prost::alloc::string::String,
                >,
            }
            /// Общий статус ответа на запрос подтверждения.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Status {
                Unspecified = 0,
                /// Форма успешно подтверждена.
                Approved = 1,
                /// Форма отклонена (одно или несколько полей неверны).
                Rejected = 2,
            }
            impl Status {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::Approved => "APPROVED",
                        Self::Rejected => "REJECTED",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "APPROVED" => Some(Self::Approved),
                        "REJECTED" => Some(Self::Rejected),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metadata {
        #[prost(oneof = "metadata::Identifier", tags = "1, 2, 3, 4, 5, 6, 7")]
        pub identifier: ::core::option::Option<metadata::Identifier>,
    }
    /// Nested message and enum types in `Metadata`.
    pub mod metadata {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(string, tag = "1")]
            GoogleAuthenticatorSecret(::prost::alloc::string::String),
            #[prost(message, tag = "2")]
            Session(super::super::Session),
            #[prost(string, tag = "3")]
            MnemonicWords(::prost::alloc::string::String),
            #[prost(string, tag = "4")]
            AuthorizationBearer(::prost::alloc::string::String),
            #[prost(message, tag = "5")]
            TransactionGroup(super::super::TransactionGroup),
            /// Для подтверждения добавления в "белый список".
            #[prost(message, tag = "6")]
            PaymentDestinationRequest(super::super::payment_destination::Request),
            /// Для подтверждения заявки на вывод.
            #[prost(message, tag = "7")]
            PaymentNetworkCurrencyWithdrawalBody(
                super::super::payment_network_currency_withdrawal::Body,
            ),
        }
    }
    /// Статус формы подтверждения.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Форма активна и ожидает подтверждения.
        Active = 1,
        /// Форма была успешно подтверждена.
        Approved = 2,
        /// В верификации было отказано (например, исчерпаны попытки).
        Rejected = 3,
        /// Форма была отменена пользователем или системой.
        Cancelled = 4,
        /// Срок действия формы истек.
        Expired = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Approved => "APPROVED",
                Self::Rejected => "REJECTED",
                Self::Cancelled => "CANCELLED",
                Self::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "APPROVED" => Some(Self::Approved),
                "REJECTED" => Some(Self::Rejected),
                "CANCELLED" => Some(Self::Cancelled),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
/// ConfirmationPolicy определяет набор правил для группы форм подтверждения.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfirmationPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Время жизни формы подтверждения в секундах.
    #[prost(uint32, tag = "4")]
    pub expires_in_seconds: u32,
    /// Максимальное количество попыток ввода данных.
    #[prost(uint32, tag = "5")]
    pub verification_attempt_limit: u32,
    /// Максимальное количество запросов на генерацию нового кода.
    #[prost(uint32, tag = "6")]
    pub code_generation_attempt_limit: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `ConfirmationPolicy`.
pub mod confirmation_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ConfirmationPolicy>,
    }
}
/// Currency представляет собой финансовую единицу, такую как криптовалюта или фиат.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Currency {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Полное название валюты (например, "Bitcoin")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный символ (тикер), например, "BTC"
    #[prost(string, tag = "3")]
    pub symbol: ::prost::alloc::string::String,
    /// Количество знаков после запятой для отображения и расчетов
    #[prost(uint32, tag = "4")]
    pub precision: u32,
    /// Вид валюты (крипто/фиат/балл).
    #[prost(enumeration = "currency::kind::Id", tag = "5")]
    pub kind: i32,
    /// Текущий операционный статус валюты
    #[prost(enumeration = "currency::status::Id", tag = "6")]
    pub status: i32,
    /// Политика, управляющая поведением валюты
    #[prost(uint32, tag = "7")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Currency`.
pub mod currency {
    /// Определяет операционный статус валюты.
    /// Эта модель-обертка позволяет в будущем расширять статус дополнительными полями (например, `reason`).
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {
        #[prost(enumeration = "status::Id", tag = "1")]
        pub id: i32,
    }
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Статус не определен.
            Unspecified = 0,
            /// Активна. Доступна для всех операций.
            Active = 1,
            /// Только просмотр/вывод. Новые депозиты и торговые операции невозможны.
            ViewOnly = 2,
            /// Тех. обслуживание. Операции временно приостановлены.
            Maintenance = 3,
            /// Неактивна. Полностью отключена, но может быть активирована.
            Inactive = 4,
            /// Устарела. Валюта больше не поддерживается и сохранена только для истории.
            Deprecated = 5,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::ViewOnly => "VIEW_ONLY",
                    Self::Maintenance => "MAINTENANCE",
                    Self::Inactive => "INACTIVE",
                    Self::Deprecated => "DEPRECATED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "VIEW_ONLY" => Some(Self::ViewOnly),
                    "MAINTENANCE" => Some(Self::Maintenance),
                    "INACTIVE" => Some(Self::Inactive),
                    "DEPRECATED" => Some(Self::Deprecated),
                    _ => None,
                }
            }
        }
    }
    /// Определяет основной вид валюты для применения общей логики.
    /// Имя `Kind` выбрано, чтобы избежать конфликтов с зарезервированным словом `Type`.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Kind {
        #[prost(enumeration = "kind::Id", tag = "1")]
        pub id: i32,
    }
    /// Nested message and enum types in `Kind`.
    pub mod kind {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Вид не указан.
            Unspecified = 0,
            /// Криптовалюта.
            Crypto = 1,
            /// Фиатная валюта.
            Fiat = 2,
            /// Внутренний балл.
            Point = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Crypto => "CRYPTO",
                    Self::Fiat => "FIAT",
                    Self::Point => "POINT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "CRYPTO" => Some(Self::Crypto),
                    "FIAT" => Some(Self::Fiat),
                    "POINT" => Some(Self::Point),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID валюты
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный символ (тикер), например, "BTC"
            #[prost(string, tag = "2")]
            Symbol(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Currency>,
    }
}
/// CurrencyPolicy определяет набор правил для группы валют.
/// Конкретная логика политики (например, требования к KYC для операций) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CurrencyPolicy`.
pub mod currency_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPolicy>,
    }
}
/// CurrencyPair представляет собой декларативную связь между двумя валютами.
/// Эта модель является справочной, но несет в себе операционный статус и ссылку на политику,
/// которые определяют правила для других систем, использующих эту пару (например, торговых).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyPair {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальный символ пары (например, "BTCUSDT")
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    /// ID базовой валюты (например, BTC)
    #[prost(uint32, tag = "3")]
    pub base_currency_id: u32,
    /// ID котируемой валюты (например, USDT)
    #[prost(uint32, tag = "4")]
    pub quote_currency_id: u32,
    /// Текущий операционный статус пары.
    #[prost(enumeration = "currency_pair::Status", tag = "5")]
    pub status: i32,
    /// Политика, управляющая правилами для этой пары.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `CurrencyPair`.
pub mod currency_pair {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID пары
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный символ пары, например, "BTCUSDT"
            #[prost(string, tag = "2")]
            Symbol(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPair>,
    }
    /// Определяет операционный статус торговой пары.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Активна. Торговля разрешена.
        Active = 1,
        /// Только просмотр. Новые ордера не принимаются, но можно просматривать историю.
        ViewOnly = 2,
        /// Тех. обслуживание. Торговля временно приостановлена.
        Maintenance = 3,
        /// Неактивна. Торговля приостановлена и может быть возобновлена.
        Inactive = 4,
        /// Устарела. Пара больше не поддерживается и скрыта из основных списков, но сохранена в системе для истории.
        Deprecated = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::ViewOnly => "VIEW_ONLY",
                Self::Maintenance => "MAINTENANCE",
                Self::Inactive => "INACTIVE",
                Self::Deprecated => "DEPRECATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "VIEW_ONLY" => Some(Self::ViewOnly),
                "MAINTENANCE" => Some(Self::Maintenance),
                "INACTIVE" => Some(Self::Inactive),
                "DEPRECATED" => Some(Self::Deprecated),
                _ => None,
            }
        }
    }
}
/// CurrencyPairPolicy определяет набор правил для группы валютных пар.
/// Конкретная логика политики (например, лимиты на торговлю, требования к марже) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyPairPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CurrencyPairPolicy`.
pub mod currency_pair_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPairPolicy>,
    }
}
/// Relationship представляет собой результат проверки иерархической связи между двумя объектами.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Relationship {
    /// Базовый ID элемента, от которого строим отношение.
    #[prost(uint32, tag = "1")]
    pub base_id: u32,
    /// ID целевого элемента, чье отношение к базовому описывается.
    #[prost(uint32, tag = "2")]
    pub target_id: u32,
    /// Состояние отношения между базовым и целевым элементами.
    #[prost(message, optional, tag = "3")]
    pub state: ::core::option::Option<relationship::State>,
}
/// Nested message and enum types in `Relationship`.
pub mod relationship {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct State {
        /// Тип отношения между объектами.
        #[prost(enumeration = "state::Kind", tag = "1")]
        pub kind: i32,
        /// Разница в уровнях (для TEAM и UPLINE).
        #[prost(uint32, optional, tag = "4")]
        pub level_diff: ::core::option::Option<u32>,
        /// Номер ветки, в которой находится дочерний объект (для TEAM).
        #[prost(uint32, optional, tag = "5")]
        pub branch_number: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `State`.
    pub mod state {
        /// Определяет тип иерархической связи.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            /// Отсутствие отношения между объектами.
            None = 0,
            /// Отношение не определено (например, один из объектов не найден).
            Error = 1,
            /// Тот же самый объект (сравнение объекта с самим собой).
            Personal = 2,
            /// Целевой объект является дочерним по отношению к базовому (в его команде).
            Team = 3,
            /// Целевой объект является родительским по отношению к базовому (в его спонсорской линии).
            Upline = 4,
            /// Объекты находятся в одной иерархии, но не связаны по вертикали (например, "братья").
            Sideways = 5,
            /// Объекты находятся в разных, не связанных иерархиях.
            Separate = 6,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Error => "ERROR",
                    Self::Personal => "PERSONAL",
                    Self::Team => "TEAM",
                    Self::Upline => "UPLINE",
                    Self::Sideways => "SIDEWAYS",
                    Self::Separate => "SEPARATE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "ERROR" => Some(Self::Error),
                    "PERSONAL" => Some(Self::Personal),
                    "TEAM" => Some(Self::Team),
                    "UPLINE" => Some(Self::Upline),
                    "SIDEWAYS" => Some(Self::Sideways),
                    "SEPARATE" => Some(Self::Separate),
                    _ => None,
                }
            }
        }
    }
}
/// Distributor представляет участника или узел в партнерской или дистрибьюторской сети.
/// Эта сущность связана с системным аккаунтом (Account) и может иметь иерархические связи.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Distributor {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное, человекочитаемое имя (псевдоним, бренд).
    #[prost(string, optional, tag = "2")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub invite_code: ::prost::alloc::string::String,
    /// ID вышестоящего дистрибьютора
    #[prost(uint32, tag = "4")]
    pub parent_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках вышестоящего дистрибьютора (parent_id)
    #[prost(uint32, tag = "5")]
    pub parent_entity_id: u32,
    /// Идентификатор ответвления от вышестоящего дистрибьютора (parent_id)
    #[prost(uint32, tag = "6")]
    pub parent_branch_id: u32,
    /// ID сети, к которому относится дистрибьютор
    #[prost(uint32, tag = "7")]
    pub network_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках сети (network_id)
    #[prost(uint32, tag = "8")]
    pub network_entity_id: u32,
    /// ID аккаунта, владеющего дистрибьютором
    #[prost(uint32, tag = "9")]
    pub account_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках аккаунта (account_id)
    #[prost(uint32, tag = "10")]
    pub account_entity_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках пары (network_id и account_id)
    #[prost(uint32, tag = "11")]
    pub network_account_entity_id: u32,
    /// ID партиции, к которому относится дистрибьютор
    #[prost(uint32, tag = "12")]
    pub network_partition_id: u32,
    /// Глобальный уровень глубины
    #[prost(uint32, tag = "13")]
    pub level: u32,
    /// Количество дочерних дистрибьюторов
    #[prost(uint32, tag = "14")]
    pub children_quantity: u32,
    /// Количество дистрибьюторов в структуре
    #[prost(uint32, tag = "15")]
    pub structure_quantity: u32,
    /// Максимальный уровень дистрибьютора в структуре
    #[prost(uint32, tag = "16")]
    pub structure_level_max: u32,
    /// ID политики, применяемой к этому дистрибьютору.
    #[prost(uint32, tag = "17")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "18")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "19")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "20")]
    pub relationship_state: ::core::option::Option<relationship::State>,
}
/// Nested message and enum types in `Distributor`.
pub mod distributor {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации дистрибьютора
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3, 4, 5, 6, 7")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentBranch {
            /// ID вышестоящего дистрибьютора
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Числовой идентификатор ветки
            #[prost(uint32, tag = "2")]
            pub parent_branch_number: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentEntity {
            /// ID вышестоящего дистрибьютора
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках вышестоящего дистрибьютора
            #[prost(uint32, tag = "2")]
            pub parent_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkEntity {
            /// ID сети, к которому относится дистрибьютор
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках сети (network_id)
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AccountEntity {
            /// ID аккаунта, владеющего дистрибьютором
            #[prost(uint32, tag = "1")]
            pub account_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках аккаунта (account_id)
            #[prost(uint32, tag = "2")]
            pub account_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkAccountEntity {
            /// ID сети, к которому относится дистрибьютор
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// ID аккаунта, владеющего дистрибьютором
            #[prost(uint32, tag = "2")]
            pub account_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках пары (network_id и account_id)
            #[prost(uint32, tag = "3")]
            pub network_account_entity_id: u32,
        }
        /// Различные способы идентификации дистрибьютора
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID дистрибьютора
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя дистрибьютора/бренда
            #[prost(string, tag = "2")]
            Username(::prost::alloc::string::String),
            #[prost(message, tag = "3")]
            ParentBranch(ParentBranch),
            #[prost(message, tag = "4")]
            ParentEntity(ParentEntity),
            #[prost(message, tag = "5")]
            NetworkEntity(NetworkEntity),
            #[prost(message, tag = "6")]
            AccountEntity(AccountEntity),
            #[prost(message, tag = "7")]
            NetworkAccountEntity(NetworkAccountEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Distributor>,
    }
}
/// DistributorPolicy определяет набор правил для группы дистрибьюторов.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DistributorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorPolicy`.
pub mod distributor_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorPolicy>,
    }
}
/// DistributorBranch представляет собой иерархическую связь или "ветку" между дистрибьюторами.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DistributorBranch {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего дистрибьютора
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Числовой идентификатор ветки от вышестоящего дистрибьютора
    #[prost(uint32, tag = "3")]
    pub parent_branch_number: u32,
    /// ID дочернего дистрибьютора, если ветка занята
    #[prost(uint32, optional, tag = "4")]
    pub child_id: ::core::option::Option<u32>,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, управляющая поведением ветки.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `DistributorBranch`.
pub mod distributor_branch {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID ветки дистрибьютора
            #[prost(uint32, tag = "1")]
            Id(u32),
            #[prost(message, tag = "2")]
            ParentBranch(super::super::distributor::id::ParentBranch),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorBranch>,
    }
}
/// DistributorBranchPolicy определяет набор правил для группы веток дистрибьюторов.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DistributorBranchPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorBranchPolicy`.
pub mod distributor_branch_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorBranchPolicy>,
    }
}
/// GoogleAuthenticator представляет собой настройки двухфакторной аутентификации (2FA) для пользователя.
/// Эта модель НЕ содержит секретный ключ из соображений безопасности.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAuthenticator {
    /// Текущий статус настройки 2FA
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Текущее состояние запроса на изменение настроек 2FA
    #[prost(message, optional, tag = "2")]
    pub confirmation: ::core::option::Option<Confirmation>,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `GoogleAuthenticator`.
pub mod google_authenticator {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::GoogleAuthenticator>,
    }
}
/// Exchange - это высокоуровневая модель, представляющая собой торговую площадку или биржу.
/// Она определяет общее пространство и правила, в рамках которых происходят торговые операции.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Exchange {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя биржи.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Текущий операционный статус.
    #[prost(enumeration = "exchange::status::Id", tag = "4")]
    pub status: i32,
    /// ID политики, управляющей биржей (ExchangePolicy).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Exchange`.
pub mod exchange {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя биржи
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Exchange>,
    }
    /// Операционный статус биржи.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Биржа активна и торги разрешены.
            Active = 1,
            /// Биржа на тех. обслуживании, торги приостановлены.
            Maintenance = 2,
            /// Биржа закрыта и больше не используется.
            Retired = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Maintenance => "MAINTENANCE",
                    Self::Retired => "RETIRED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "MAINTENANCE" => Some(Self::Maintenance),
                    "RETIRED" => Some(Self::Retired),
                    _ => None,
                }
            }
        }
    }
}
/// ExchangeCurrencyPair - это операционная модель, которая связывает валютную пару (CurrencyPair)
/// с торговой площадкой (Exchange) и определяет правила торгов для этой пары на этой площадке.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExchangeCurrencyPair {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<exchange_currency_pair::Id>,
    /// Текущий операционный статус.
    #[prost(enumeration = "exchange_currency_pair::status::Id", tag = "2")]
    pub status: i32,
    /// Настройки для операции покупки базовой валюты.
    #[prost(message, optional, tag = "3")]
    pub buy_settings: ::core::option::Option<exchange_currency_pair::OperationSettings>,
    /// Настройки для операции продажи базовой валюты.
    #[prost(message, optional, tag = "4")]
    pub sell_settings: ::core::option::Option<exchange_currency_pair::OperationSettings>,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `ExchangeCurrencyPair`.
pub mod exchange_currency_pair {
    /// Составной идентификатор.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint32, tag = "1")]
        pub exchange_id: u32,
        #[prost(uint32, tag = "2")]
        pub currency_pair_id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ExchangeCurrencyPair>,
    }
    /// Операционный статус пары на данной бирже.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Торги по паре активны.
            Active = 1,
            /// Торги временно приостановлены для тех. обслуживания.
            Maintenance = 2,
            /// Новые ордера не принимаются, но можно просматривать историю.
            ViewOnly = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Maintenance => "MAINTENANCE",
                    Self::ViewOnly => "VIEW_ONLY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "MAINTENANCE" => Some(Self::Maintenance),
                    "VIEW_ONLY" => Some(Self::ViewOnly),
                    _ => None,
                }
            }
        }
    }
    /// Конфигурация для одной торговой операции (покупка или продажа).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OperationSettings {
        /// Разрешена ли операция.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
        /// Минимальная сумма операции (в базовой валюте).
        #[prost(string, optional, tag = "2")]
        pub min_amount: ::core::option::Option<::prost::alloc::string::String>,
        /// Максимальная сумма операции (в базовой валюте).
        #[prost(string, optional, tag = "3")]
        pub max_amount: ::core::option::Option<::prost::alloc::string::String>,
        /// Комиссия, взимаемая с базовой валюты.
        #[prost(message, optional, tag = "4")]
        pub base_fee: ::core::option::Option<super::CalculationGroup>,
        /// Комиссия, взимаемая с котируемой валюты.
        #[prost(message, optional, tag = "5")]
        pub quote_fee: ::core::option::Option<super::CalculationGroup>,
    }
}
/// ExchangePolicy определяет набор правил для группы бирж (Exchange).
/// Конкретная логика политики (например, доступные типы ордеров) реализуется на стороне бэкенда.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExchangePolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Торговая модель, диктуемая этой политикой.
    #[prost(enumeration = "exchange_policy::TradingModel", tag = "4")]
    pub trading_model: i32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `ExchangePolicy`.
pub mod exchange_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ExchangePolicy>,
    }
    /// Определяет основную торговую модель, используемую на бирже.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TradingModel {
        Unspecified = 0,
        /// Модель обменника. Цены задаются системой (buy/sell). Тикер использует `ExchangerRate`.
        Exchanger = 1,
        /// Модель биржи. Цены формируются на основе стакана ордеров. Тикер использует `MarketRate`.
        OrderBook = 2,
    }
    impl TradingModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Exchanger => "EXCHANGER",
                Self::OrderBook => "ORDER_BOOK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "EXCHANGER" => Some(Self::Exchanger),
                "ORDER_BOOK" => Some(Self::OrderBook),
                _ => None,
            }
        }
    }
}
/// Ticker представляет собой сводку рыночных данных (тикер) для торговой пары на конкретной бирже.
/// Эта модель содержит высокодинамичные данные, которые часто обновляются.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ticker {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<ticker::Id>,
    /// Время последнего обновления тикера.
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "ticker::RateKind", tags = "2, 3")]
    pub rate_kind: ::core::option::Option<ticker::RateKind>,
}
/// Nested message and enum types in `Ticker`.
pub mod ticker {
    /// Составной идентификатор, связывающий тикер с торговой парой на бирже.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint32, tag = "1")]
        pub exchange_id: u32,
        #[prost(uint32, tag = "2")]
        pub currency_pair_id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Ticker>,
    }
    /// Курс для обменника с фиксированными ценами покупки и продажи.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ExchangerRate {
        /// Цена, по которой система ПОКУПАЕТ базовую валюту у пользователя.
        #[prost(string, optional, tag = "1")]
        pub buy_price: ::core::option::Option<::prost::alloc::string::String>,
        /// Цена, по которой система ПРОДАЕТ базовую валюту пользователю.
        #[prost(string, optional, tag = "2")]
        pub sell_price: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Полные рыночные данные для биржи.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MarketRate {
        /// Цена последней сделки.
        #[prost(string, tag = "1")]
        pub last_price: ::prost::alloc::string::String,
        /// Лучшая цена на покупку (bid).
        #[prost(string, tag = "2")]
        pub best_bid_price: ::prost::alloc::string::String,
        /// Лучшая цена на продажу (ask).
        #[prost(string, tag = "3")]
        pub best_ask_price: ::prost::alloc::string::String,
        /// Изменение цены за 24 часа.
        #[prost(string, tag = "4")]
        pub price_change_24h: ::prost::alloc::string::String,
        /// Изменение цены в процентах за 24 часа.
        #[prost(string, tag = "5")]
        pub price_change_percent_24h: ::prost::alloc::string::String,
        /// Объем торгов в базовой валюте за 24 часа.
        #[prost(string, tag = "6")]
        pub base_volume_24h: ::prost::alloc::string::String,
        /// Объем торгов в котируемой валюте за 24 часа.
        #[prost(string, tag = "7")]
        pub quote_volume_24h: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum RateKind {
        /// Для обменников с фиксированным курсом.
        #[prost(message, tag = "2")]
        ExchangerRate(ExchangerRate),
        /// Для бирж с динамическим курсом.
        #[prost(message, tag = "3")]
        MarketRate(MarketRate),
    }
}
/// GoogleAuthenticatorPolicy определяет набор правил для группы настроек 2FA.
/// Конкретная логика политики (например, обязательность 2FA) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GoogleAuthenticatorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `GoogleAuthenticatorPolicy`.
pub mod google_authenticator_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::GoogleAuthenticatorPolicy>,
    }
}
/// Mnemonic представляет конфигурацию для мнемонических фраз.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mnemonic {
    /// enabled указывает, включена ли функция мнемонической фразы.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// confirmation представляет текущее состояние запроса на изменение настроек мнемонической фразы.
    #[prost(message, optional, tag = "2")]
    pub confirmation: ::core::option::Option<Confirmation>,
    /// created_at - время создания конфигурации мнемонической фразы.
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// updated_at - время последнего обновления конфигурации мнемонической фразы.
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Mnemonic`.
pub mod mnemonic {
    /// List представляет список мнемонических фраз.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// items содержит список мнемонических фраз.
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Mnemonic>,
    }
    /// Word представляет отдельное слово в мнемонической фразе.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Word {
        /// index - порядковый номер слова в мнемонической фразе (начиная с 0).
        ///
        /// Индекс слова в мнемонической фразе
        #[prost(uint32, tag = "1")]
        pub index: u32,
        /// value - само слово.
        ///
        /// Слово в мнемонической фразе
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Word`.
    pub mod word {
        /// List представляет список слов в мнемонической фразе.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct List {
            /// items содержит список слов.
            #[prost(message, repeated, tag = "1")]
            pub items: ::prost::alloc::vec::Vec<super::Word>,
        }
    }
}
/// Network представляет собой основную партнерскую или дистрибьюторскую сеть.
/// Она служит контейнером для дистрибьюторов и их иерархических связей.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Network {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное строковое имя для идентификации сети
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ID корневой партиции (NetworkPartition) для данной сети
    #[prost(uint32, tag = "3")]
    pub root_partition_id: u32,
    /// Политика, управляющая поведением всей сети.
    #[prost(uint32, tag = "4")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Network`.
pub mod network {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации сети
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Различные способы идентификации сети
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID сети
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя сети
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Network>,
    }
}
/// NetworkPolicy определяет набор правил для группы сетей.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPolicy`.
pub mod network_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPolicy>,
    }
}
/// NetworkAccount представляет собой связь между сетью (Network) и универсальным аккаунтом (Account).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkAccount {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Идентификатор сети
    #[prost(uint32, tag = "2")]
    pub network_id: u32,
    /// Порядковый номер связи в рамках сети (network_id)
    #[prost(uint32, tag = "3")]
    pub network_entity_id: u32,
    /// Идентификатор аккаунта
    #[prost(uint32, tag = "4")]
    pub account_id: u32,
    /// Порядковый номер связи в рамках аккаунта (account_id)
    #[prost(uint32, tag = "5")]
    pub account_entity_id: u32,
    /// ID политики, применяемой к этой связи. Определяет ее статус и правила.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkAccount`.
pub mod network_account {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации связи
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Составной идентификатор для связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Pair {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Идентификатор аккаунта
            #[prost(uint32, tag = "2")]
            pub account_id: u32,
        }
        /// Различные способы идентификации связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID связи
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по паре сеть-аккаунт
            #[prost(message, tag = "2")]
            Pair(Pair),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkAccount>,
    }
}
/// NetworkAccountPolicy определяет набор правил для группы связей NetworkAccount.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkAccountPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkAccountPolicy`.
pub mod network_account_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkAccountPolicy>,
    }
}
/// NetworkPartition представляет собой выделенную часть или "партицию" внутри сети (Network).
/// Партиция начинается с определенного корневого дистрибьютора и может функционировать как отдельная подсеть.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkPartition {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID родительской сети
    #[prost(uint32, tag = "2")]
    pub network_id: u32,
    /// Порядковый номер партиции в рамках сети
    #[prost(uint32, tag = "3")]
    pub network_entity_id: u32,
    /// ID корневого дистрибьютора, с которого начинается партиция
    #[prost(uint32, tag = "4")]
    pub root_distributor_id: u32,
    /// Политика, управляющая поведением партиции (например, возможностью слияния).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    /// Флаг, указывающий, что партиция была слита с другой и больше не активна.
    #[prost(bool, tag = "6")]
    pub is_archived: bool,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPartition`.
pub mod network_partition {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации партиции
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по порядковому номеру в сети
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkEntity {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор партиции в рамках сети
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        /// Различные способы идентификации партиции
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID партиции
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по сети и порядковому номеру
            #[prost(message, tag = "2")]
            Entity(NetworkEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPartition>,
    }
}
/// NetworkPartitionPolicy определяет набор правил для группы партиций сети.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkPartitionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Определяет, могут ли партиции, подчиненные этой политике, быть слиты с другими. false - аналог "Standalone".
    #[prost(bool, tag = "4")]
    pub is_mergeable: bool,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "89")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPartitionPolicy`.
pub mod network_partition_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPartitionPolicy>,
    }
}
/// Модель, описывающая платежную сеть или расчетную схему.
/// Пример: блокчейн (Tron, Ethereum), банковская система (SEPA, SWIFT), внешняя платежная система (PayPal, Stripe).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentNetwork {
    /// Глобальный числовой ID платежной сети.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальный код (tron, ethereum, sepa)
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    /// Человекочитаемое имя (Ethereum, SEPA)
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Описание
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Статус платежной сети.
    #[prost(enumeration = "payment_network::status::Id", tag = "5")]
    pub status: i32,
    /// Тип платежной сети.
    #[prost(enumeration = "payment_network::network_type::Id", tag = "6")]
    pub network_type: i32,
    /// Время создания записи о платежной сети.
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Время последнего обновления.
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PaymentNetwork`.
pub mod payment_network {
    /// Идентификатор для поиска платежной сети.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный числовой ID платежной сети.
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный строковый код (напр., "tron", "ethereum").
            #[prost(string, tag = "2")]
            Code(::prost::alloc::string::String),
        }
    }
    /// Список платежных сетей.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::PaymentNetwork>,
    }
    /// Статус платежной сети.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Неопределенный статус.
            Unspecified = 0,
            /// Платежная сеть работает в штатном режиме.
            Active = 1,
            /// Платежная сеть отключена администратором.
            Inactive = 2,
            /// Работа платежной сети временно приостановлена (например, из-за проблем с ней).
            Suspended = 3,
            /// Устаревшая платежная сеть, не рекомендуется к использованию.
            Retired = 4,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Inactive => "INACTIVE",
                    Self::Suspended => "SUSPENDED",
                    Self::Retired => "RETIRED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "INACTIVE" => Some(Self::Inactive),
                    "SUSPENDED" => Some(Self::Suspended),
                    "RETIRED" => Some(Self::Retired),
                    _ => None,
                }
            }
        }
    }
    /// Тип платежной сети, помогает группировать и применять общую логику.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NetworkType {}
    /// Nested message and enum types in `NetworkType`.
    pub mod network_type {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Тип не определен.
            Unspecified = 0,
            /// Сеть блокчейна (напр., Tron, Ethereum).
            Blockchain = 1,
            /// Банковская система (напр., SWIFT, SEPA).
            Bank = 2,
            /// Внешняя платежная система (напр., PayPal, Stripe).
            PaymentSystem = 3,
            /// Внутренняя операция, проводимая вручную (напр., зачисление/выдача наличных).
            Manual = 4,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Blockchain => "BLOCKCHAIN",
                    Self::Bank => "BANK",
                    Self::PaymentSystem => "PAYMENT_SYSTEM",
                    Self::Manual => "MANUAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "BLOCKCHAIN" => Some(Self::Blockchain),
                    "BANK" => Some(Self::Bank),
                    "PAYMENT_SYSTEM" => Some(Self::PaymentSystem),
                    "MANUAL" => Some(Self::Manual),
                    _ => None,
                }
            }
        }
    }
}
/// === Универсальные настройки операции (депозит/вывод) ===
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentOperationSettings {
    /// Минимальная сумма (null = без лимита)
    #[prost(string, optional, tag = "1")]
    pub min_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// Максимальная сумма (null = без лимита)
    #[prost(string, optional, tag = "2")]
    pub max_amount: ::core::option::Option<::prost::alloc::string::String>,
    /// Политика для min
    #[prost(
        enumeration = "payment_operation_settings::out_of_range_policy::Id",
        tag = "3"
    )]
    pub below_min_policy: i32,
    /// Политика для max
    #[prost(
        enumeration = "payment_operation_settings::out_of_range_policy::Id",
        tag = "4"
    )]
    pub above_max_policy: i32,
    /// Разрешена ли операция
    #[prost(bool, tag = "5")]
    pub enabled: bool,
    /// Комиссии
    #[prost(message, optional, tag = "6")]
    pub fee: ::core::option::Option<CalculationGroup>,
}
/// Nested message and enum types in `PaymentOperationSettings`.
pub mod payment_operation_settings {
    /// Политика при выходе за пределы лимита
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct OutOfRangePolicy {}
    /// Nested message and enum types in `OutOfRangePolicy`.
    pub mod out_of_range_policy {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// отклонить
            Reject = 1,
            /// зависает, требует ручной обработки
            Hold = 2,
            /// принять частично (до max)
            PartialAccept = 3,
            /// принять всю сумму (игнорировать max)
            AcceptFull = 4,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Reject => "REJECT",
                    Self::Hold => "HOLD",
                    Self::PartialAccept => "PARTIAL_ACCEPT",
                    Self::AcceptFull => "ACCEPT_FULL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "REJECT" => Some(Self::Reject),
                    "HOLD" => Some(Self::Hold),
                    "PARTIAL_ACCEPT" => Some(Self::PartialAccept),
                    "ACCEPT_FULL" => Some(Self::AcceptFull),
                    _ => None,
                }
            }
        }
    }
}
/// Определяет, что платежная сеть поддерживает конкретную валюту,
/// и описывает статус этой поддержки.
/// Логическим ключом является пара (payment_network_id, currency_id).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentNetworkCurrency {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<payment_network_currency::Id>,
    /// Статус поддержки валюты в платежной сети.
    #[prost(enumeration = "payment_network_currency::status::Id", tag = "2")]
    pub status: i32,
    /// Технические параметры, специфичные для данной платежной сети.
    #[prost(message, optional, tag = "3")]
    pub network_settings: ::core::option::Option<PaymentNetworkOperationSettings>,
    /// Настройки депозитов
    #[prost(message, optional, tag = "4")]
    pub deposit_settings: ::core::option::Option<PaymentOperationSettings>,
    /// Настройки выводов
    #[prost(message, optional, tag = "5")]
    pub withdraw_settings: ::core::option::Option<PaymentOperationSettings>,
    /// Время создания этой связи.
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Время последнего обновления.
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PaymentNetworkCurrency`.
pub mod payment_network_currency {
    /// Составной идентификатор.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// ID платежной сети.
        #[prost(uint32, tag = "1")]
        pub payment_network_id: u32,
        /// ID валюты.
        #[prost(uint32, tag = "2")]
        pub currency_id: u32,
    }
    /// Список связей.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::PaymentNetworkCurrency>,
    }
    /// Статус поддержки валюты в платежной сети.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Связка "платежная сеть-валюта" активна и работает штатно.
            Active = 1,
            /// Связка отключена администратором.
            Inactive = 2,
            /// Временные ограничения (тех. работы). Операции могут быть недоступны.
            Suspended = 3,
            /// Поддержка прекращена и больше не будет возобновлена.
            Retired = 4,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Inactive => "INACTIVE",
                    Self::Suspended => "SUSPENDED",
                    Self::Retired => "RETIRED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "INACTIVE" => Some(Self::Inactive),
                    "SUSPENDED" => Some(Self::Suspended),
                    "RETIRED" => Some(Self::Retired),
                    _ => None,
                }
            }
        }
    }
}
/// InviteLink представляет собой реферальную ссылку, используемую для привлечения новых участников.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InviteLink {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Уникальный код, используемый в URL (например, "REF123XYZ").
    #[prost(string, tag = "2")]
    pub invite_code: ::prost::alloc::string::String,
    /// Имя ссылки, видимое ее создателю.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Не изменяемая ссылка, которая не может быть изменена.
    #[prost(bool, tag = "4")]
    pub fixed: bool,
    /// Статус ссылки (активна/неактивна).
    #[prost(bool, tag = "5")]
    pub enabled: bool,
    #[prost(uint32, tag = "6")]
    pub account_id: u32,
    #[prost(uint32, tag = "7")]
    pub account_entity_id: u32,
    #[prost(uint32, tag = "8")]
    pub used_quantity: u32,
    #[prost(uint64, tag = "9")]
    pub cursor_pool_id: u64,
    #[prost(message, repeated, tag = "10")]
    pub pools: ::prost::alloc::vec::Vec<invite_link::Pool>,
    #[prost(message, optional, tag = "11")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `InviteLink`.
pub mod invite_link {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(uint64, tag = "1")]
            Id(u64),
            /// Уникальный код ссылки.
            #[prost(string, tag = "2")]
            InviteCode(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::InviteLink>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct View {
        /// Аккаунт, который является создателем и владельцем InviteLink.
        #[prost(uint32, tag = "1")]
        pub owner_account_id: u32,
        /// Аккаунты (который является владельцем InviteLink и Distributor).
        #[prost(message, repeated, tag = "2")]
        pub accounts: ::prost::alloc::vec::Vec<super::Account>,
        /// Сеть, к которой относится ссылка.
        #[prost(message, optional, tag = "3")]
        pub network: ::core::option::Option<super::Network>,
        /// Дистрибьютор-наставник.
        #[prost(message, optional, tag = "4")]
        pub distributor: ::core::option::Option<super::Distributor>,
        /// Найденный дистрибьютор, является статичным результатом или динамичным.
        #[prost(bool, tag = "5")]
        pub is_dynamic: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Pool {
        #[prost(uint64, tag = "1")]
        pub id: u64,
        #[prost(uint64, tag = "2")]
        pub invite_link_id: u64,
        #[prost(uint32, tag = "3")]
        pub invite_link_order_id: u32,
        #[prost(bool, tag = "4")]
        pub enabled: bool,
        #[prost(uint32, tag = "5")]
        pub cycle_used: u32,
        #[prost(uint32, optional, tag = "6")]
        pub cycle_limit: ::core::option::Option<u32>,
        #[prost(uint64, tag = "7")]
        pub cursor_entity_id: u64,
        #[prost(uint32, tag = "8")]
        pub cursor_usage_value: u32,
        #[prost(message, repeated, tag = "9")]
        pub entities: ::prost::alloc::vec::Vec<pool::Entity>,
        #[prost(message, optional, tag = "10")]
        pub created_at: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "11")]
        pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `Pool`.
    pub mod pool {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Entity {
            #[prost(uint64, tag = "1")]
            pub id: u64,
            #[prost(uint64, tag = "2")]
            pub invite_link_pool_id: u64,
            #[prost(uint32, tag = "3")]
            pub distributor_id: u32,
            #[prost(uint32, optional, tag = "4")]
            pub usage_limit: ::core::option::Option<u32>,
            #[prost(message, repeated, tag = "5")]
            pub logs: ::prost::alloc::vec::Vec<entity::Log>,
        }
        /// Nested message and enum types in `Entity`.
        pub mod entity {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Log {
                #[prost(uint64, tag = "1")]
                pub id: u64,
                #[prost(uint64, tag = "2")]
                pub invite_link_pool_entity_id: u64,
                #[prost(uint32, tag = "3")]
                pub cycle_id: u32,
                #[prost(uint32, tag = "4")]
                pub usage_id: u32,
                #[prost(uint32, tag = "5")]
                pub distributor_id: u32,
                #[prost(message, optional, tag = "6")]
                pub created_at: ::core::option::Option<::prost_types::Timestamp>,
            }
        }
    }
    /// Тип реферальной ссылки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        /// Персональная: всегда ведет к дистрибьютору, связанному с аккаунтом-владельцем.
        Distributor = 1,
        /// Коллективная: использует внутреннюю логику (определяемую политикой) для определения конечного дистрибьютора.
        Pool = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KIND_UNSPECIFIED",
                Self::Distributor => "KIND_DISTRIBUTOR",
                Self::Pool => "KIND_POOL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "KIND_DISTRIBUTOR" => Some(Self::Distributor),
                "KIND_POOL" => Some(Self::Pool),
                _ => None,
            }
        }
    }
    /// Статус жизненного цикла ссылки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Активна и может быть использована для регистрации.
        Active = 1,
        /// Неактивна и не может быть использована.
        Inactive = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Active => "STATUS_ACTIVE",
                Self::Inactive => "STATUS_INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_ACTIVE" => Some(Self::Active),
                "STATUS_INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// ReferralLinkPolicy определяет набор правил для группы реферальных ссылок.
/// Для коллективных ссылок, эта политика может описывать логику балансировщика.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReferralLinkPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint64, tag = "2")]
    pub trace_id: u64,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `ReferralLinkPolicy`.
pub mod referral_link_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ReferralLinkPolicy>,
    }
}
/// Ledger - это атомарный счет для учета активов одной валюты.
/// Он хранит общую сумму зачислений и списаний, из которых вычисляется текущий баланс.
/// Поведение счета регулируется набором флагов.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ledger {
    /// Уникальный идентификатор счета.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Актив, который учитывается на этом счете.
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<Asset>,
    /// Статус счета.
    #[prost(enumeration = "ledger::status::Id", tag = "3")]
    pub status: i32,
    /// Бинарная маска флагов из `Ledger.Flags.Id`.
    #[prost(uint32, tag = "4")]
    pub flags: u32,
    #[prost(enumeration = "ledger::flags::Id", repeated, tag = "18")]
    pub view_flags: ::prost::alloc::vec::Vec<i32>,
    /// Владелец этого счета.
    #[prost(message, optional, tag = "5")]
    pub owner: ::core::option::Option<ledger::Owner>,
    /// Сумма проведенных дебетовых операций (списания).
    #[prost(string, tag = "6")]
    pub posted_debit: ::prost::alloc::string::String,
    /// Сумма проведенных кредитовых операций (зачисления).
    #[prost(string, tag = "7")]
    pub posted_credit: ::prost::alloc::string::String,
    /// Сумма ожидающих дебетовых операций.
    #[prost(string, tag = "8")]
    pub pending_debit: ::prost::alloc::string::String,
    /// Сумма ожидающих кредитовых операций.
    #[prost(string, tag = "9")]
    pub pending_credit: ::prost::alloc::string::String,
    /// Сумма запланированных дебетовых операций.
    #[prost(string, tag = "10")]
    pub scheduled_debit: ::prost::alloc::string::String,
    /// Сумма запланированных кредитовых операций.
    #[prost(string, tag = "11")]
    pub scheduled_credit: ::prost::alloc::string::String,
    /// Кредитный лимит, если разрешен флагом LIMIT_NEGATIVE.
    #[prost(string, tag = "12")]
    pub credit_limit: ::prost::alloc::string::String,
    /// Лимит овердрафта, если разрешен флагом ALLOW_OVERDRAFT_LIMIT.
    #[prost(string, tag = "13")]
    pub overdraft_limit: ::prost::alloc::string::String,
    /// Общее количество транзакций по счету.
    #[prost(uint64, tag = "14")]
    pub transactions_quantity: u64,
    /// Флаг, указывающий, что объект был инициализирован и не является значением по умолчанию.
    #[prost(bool, tag = "15")]
    pub initialized: bool,
    #[prost(message, optional, tag = "16")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "17")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Ledger`.
pub mod ledger {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Составной ключ для идентификации Ledger по его владельцу и активу.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ByOwnerAsset {
            /// Владелец счета.
            #[prost(message, optional, tag = "1")]
            pub owner: ::core::option::Option<super::Owner>,
            /// Актив, который учитывается на счете.
            #[prost(message, optional, tag = "2")]
            pub asset: ::core::option::Option<super::super::Asset>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(uint64, tag = "1")]
            Id(u64),
            #[prost(message, tag = "2")]
            ByOwnerAsset(ByOwnerAsset),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Ledger>,
    }
    /// Owner определяет владельца счета Ledger.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Owner {
        #[prost(oneof = "owner::Entity", tags = "1, 2, 3, 4")]
        pub entity: ::core::option::Option<owner::Entity>,
    }
    /// Nested message and enum types in `Owner`.
    pub mod owner {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Entity {
            /// ID пула организации.
            #[prost(uint32, tag = "1")]
            OrgPoolId(u32),
            /// ID кошелька.
            #[prost(uint32, tag = "2")]
            WalletId(u32),
            /// ID платежной сети.
            #[prost(uint32, tag = "3")]
            PaymentNetworkId(u32),
            /// ID биржи/обменника.
            #[prost(uint32, tag = "4")]
            ExchangeId(u32),
        }
    }
    /// Статус жизненного цикла счета.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Ledger активен и может участвовать в транзакциях.
            Active = 1,
            /// Ledger заморожен (операционные причины: техническая блокировка, внутренние процессы, расследование).
            /// Баланс фиксируется, новые транзакции запрещены.
            Frozen = 2,
            /// Ledger временно приостановлен (например, из-за KYC/AML проверки, риска или внешнего блокирующего события).
            /// Отличается от Frozen тем, что это обычно регуляторные/рисковые причины.
            Suspended = 3,
            /// Ledger закрыт окончательно. Баланс обнулён или переведён, новые транзакции невозможны.
            Closed = 4,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Frozen => "FROZEN",
                    Self::Suspended => "SUSPENDED",
                    Self::Closed => "CLOSED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "FROZEN" => Some(Self::Frozen),
                    "SUSPENDED" => Some(Self::Suspended),
                    "CLOSED" => Some(Self::Closed),
                    _ => None,
                }
            }
        }
    }
    /// Флаги, управляющие поведением счета. Представлены в виде битовой маски.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Flags {}
    /// Nested message and enum types in `Flags`.
    pub mod flags {
        /// Id представляет собой порядковый номер бита в маске.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Разрешено уходить в отрицательный баланс без ограничений.
            AllowNegative = 0,
            /// Разрешён минус, но в пределах `credit_limit`.
            LimitNegative = 1,
            /// Разрешён минус в пределах `overdraft_limit`.
            AllowOverdraftLimit = 2,
            /// Разрешены операции дебета (списания средств).
            AllowDebit = 3,
            /// Разрешены операции кредита (зачисления средств).
            AllowCredit = 4,
            /// Ledger временно заблокирован (операционные причины: тех. блокировка, расследование).
            /// Новые транзакции запрещены, но чтение баланса разрешено.
            Locked = 5,
            /// Ledger полностью заморожен — операции невозможны.
            /// Используется при инцидентах, сбоях или нарушениях целостности.
            Frozen = 6,
            /// Ledger помечен как подозрительный (флаг KYC/AML).
            /// Транзакции проходят дополнительную проверку, но не обязательно блокируются.
            Suspicious = 7,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::AllowNegative => "ALLOW_NEGATIVE",
                    Self::LimitNegative => "LIMIT_NEGATIVE",
                    Self::AllowOverdraftLimit => "ALLOW_OVERDRAFT_LIMIT",
                    Self::AllowDebit => "ALLOW_DEBIT",
                    Self::AllowCredit => "ALLOW_CREDIT",
                    Self::Locked => "LOCKED",
                    Self::Frozen => "FROZEN",
                    Self::Suspicious => "SUSPICIOUS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ALLOW_NEGATIVE" => Some(Self::AllowNegative),
                    "LIMIT_NEGATIVE" => Some(Self::LimitNegative),
                    "ALLOW_OVERDRAFT_LIMIT" => Some(Self::AllowOverdraftLimit),
                    "ALLOW_DEBIT" => Some(Self::AllowDebit),
                    "ALLOW_CREDIT" => Some(Self::AllowCredit),
                    "LOCKED" => Some(Self::Locked),
                    "FROZEN" => Some(Self::Frozen),
                    "SUSPICIOUS" => Some(Self::Suspicious),
                    _ => None,
                }
            }
        }
    }
}
/// Модель, представляющая одну финансовую транзакцию или "инструкцию".
/// Описывает атомарный перевод средств между двумя Хранилищами (Ledger)
/// и правила, по которым этот перевод должен быть исполнен.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LedgerTransaction {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Позволяет связать финансовую операцию с ее причиной в системе аудита.
    #[prost(uint64, tag = "2")]
    pub event_id: u64,
    #[prost(uint64, tag = "3")]
    pub source_ledger_id: u64,
    #[prost(uint64, tag = "4")]
    pub destination_ledger_id: u64,
    #[prost(enumeration = "ledger_transaction::Kind", tag = "5")]
    pub kind: i32,
    #[prost(enumeration = "ledger_transaction::Status", tag = "6")]
    pub status: i32,
    #[prost(string, tag = "7")]
    pub amount: ::prost::alloc::string::String,
    /// Правило исполнения этой транзакции.
    #[prost(message, optional, tag = "8")]
    pub execution_rule: ::core::option::Option<ledger_transaction::ExecutionRule>,
    #[prost(string, tag = "9")]
    pub source_balance_after: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub destination_balance_after: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "11")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Ссылка на транзакцию, которую эта отменяет.
    #[prost(uint64, optional, tag = "12")]
    pub cancels_transaction_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "13")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "15")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
    /// ID Заявки (LedgerRequest), которая породила эту транзакцию.
    /// Позволяет сгруппировать несколько транзакций, относящихся к одной бизнес-операции.
    #[prost(uint64, optional, tag = "16")]
    pub request_id: ::core::option::Option<u64>,
}
/// Nested message and enum types in `LedgerTransaction`.
pub mod ledger_transaction {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::LedgerTransaction>,
    }
    /// Правило исполнения: КОГДА и КАК транзакция должна повлиять на баланс.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ExecutionRule {
        #[prost(enumeration = "execution_rule::Condition", tag = "1")]
        pub condition: i32,
        /// Время исполнения (заполняется, если condition = TIME_BASED).
        #[prost(message, optional, tag = "2")]
        pub execute_at: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `ExecutionRule`.
    pub mod execution_rule {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Condition {
            Unspecified = 0,
            /// Немедленное исполнение и применение к балансу.
            Immediate = 1,
            /// Исполнение по достижению определенного времени.
            TimeBased = 2,
            /// Исполнение по внешнему триггеру (напр., подтверждение от админа).
            TriggerBased = 3,
        }
        impl Condition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "CONDITION_UNSPECIFIED",
                    Self::Immediate => "IMMEDIATE",
                    Self::TimeBased => "TIME_BASED",
                    Self::TriggerBased => "TRIGGER_BASED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                    "IMMEDIATE" => Some(Self::Immediate),
                    "TIME_BASED" => Some(Self::TimeBased),
                    "TRIGGER_BASED" => Some(Self::TriggerBased),
                    _ => None,
                }
            }
        }
    }
    /// Направление движения средств.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        Unspecified = 0,
        Debit = 1,
        Credit = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DIRECTION_UNSPECIFIED",
                Self::Debit => "DEBIT",
                Self::Credit => "CREDIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
                "DEBIT" => Some(Self::Debit),
                "CREDIT" => Some(Self::Credit),
                _ => None,
            }
        }
    }
    /// Контекст или причина транзакции.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        GatewayDeposit = 1,
        GatewayWithdrawal = 2,
        InternalTransferSpend = 3,
        InternalTransferReceive = 4,
        ExchangeSpend = 5,
        ExchangeReceive = 6,
        BonusAward = 7,
        Fee = 8,
        VoucherCreate = 9,
        VoucherRedeem = 10,
        TransferToPool = 11,
        TransferFromPool = 12,
        Mint = 13,
        Burn = 14,
        Adjustment = 15,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KIND_UNSPECIFIED",
                Self::GatewayDeposit => "GATEWAY_DEPOSIT",
                Self::GatewayWithdrawal => "GATEWAY_WITHDRAWAL",
                Self::InternalTransferSpend => "INTERNAL_TRANSFER_SPEND",
                Self::InternalTransferReceive => "INTERNAL_TRANSFER_RECEIVE",
                Self::ExchangeSpend => "EXCHANGE_SPEND",
                Self::ExchangeReceive => "EXCHANGE_RECEIVE",
                Self::BonusAward => "BONUS_AWARD",
                Self::Fee => "FEE",
                Self::VoucherCreate => "VOUCHER_CREATE",
                Self::VoucherRedeem => "VOUCHER_REDEEM",
                Self::TransferToPool => "TRANSFER_TO_POOL",
                Self::TransferFromPool => "TRANSFER_FROM_POOL",
                Self::Mint => "MINT",
                Self::Burn => "BURN",
                Self::Adjustment => "ADJUSTMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "GATEWAY_DEPOSIT" => Some(Self::GatewayDeposit),
                "GATEWAY_WITHDRAWAL" => Some(Self::GatewayWithdrawal),
                "INTERNAL_TRANSFER_SPEND" => Some(Self::InternalTransferSpend),
                "INTERNAL_TRANSFER_RECEIVE" => Some(Self::InternalTransferReceive),
                "EXCHANGE_SPEND" => Some(Self::ExchangeSpend),
                "EXCHANGE_RECEIVE" => Some(Self::ExchangeReceive),
                "BONUS_AWARD" => Some(Self::BonusAward),
                "FEE" => Some(Self::Fee),
                "VOUCHER_CREATE" => Some(Self::VoucherCreate),
                "VOUCHER_REDEEM" => Some(Self::VoucherRedeem),
                "TRANSFER_TO_POOL" => Some(Self::TransferToPool),
                "TRANSFER_FROM_POOL" => Some(Self::TransferFromPool),
                "MINT" => Some(Self::Mint),
                "BURN" => Some(Self::Burn),
                "ADJUSTMENT" => Some(Self::Adjustment),
                _ => None,
            }
        }
    }
    /// Статус жизненного цикла транзакции.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Ожидает исполнения своего правила (средства заблокированы или ожидаются).
        Pending = 1,
        /// Успешно исполнена (влияние на баланс применено).
        Executed = 2,
        /// Отклонена до исполнения.
        Rejected = 3,
        /// Отменена до исполнения.
        Canceled = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Executed => "EXECUTED",
                Self::Rejected => "REJECTED",
                Self::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "EXECUTED" => Some(Self::Executed),
                "REJECTED" => Some(Self::Rejected),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
/// Модель, определяющая "Политику" или "набор правил" для Хранилища (Ledger).
/// Она задает, какие операции разрешены для счетов, подчиняющихся этой политике.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LedgerPolicy {
    /// Глобальный числовой ID Политики.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики (например, "Standard User Policy", "System Pool Policy").
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Список типов транзакций, которые РАЗРЕШЕНЫ для счетов с этой политикой.
    /// Если список пуст, могут быть разрешены все операции (зависит от логики сервера).
    #[prost(enumeration = "ledger_transaction::Kind", repeated, tag = "3")]
    pub allowed_transaction_kinds: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `LedgerPolicy`.
pub mod ledger_policy {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::LedgerPolicy>,
    }
}
/// Locale представляет собой языковую локаль, используемую в системе для интернационализации.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Locale {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Полное название (например, "English (United States)")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный код по стандарту IETF BCP 47 (например, "en-US", "ar-SA").
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// Указывает, имеет ли язык написание справа налево (Right-to-Left).
    #[prost(bool, tag = "4")]
    pub is_rtl: bool,
    /// Текущий статус доступности локали
    #[prost(enumeration = "locale::Status", tag = "5")]
    pub status: i32,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Locale`.
pub mod locale {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID локали
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный код локали (например, "en-US")
            #[prost(string, tag = "2")]
            Code(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Locale>,
    }
    /// Определяет статус доступности локали.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Активна. Локаль доступна для выбора пользователями.
        Active = 1,
        /// Неактивна. Локаль скрыта и недоступна.
        Inactive = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// SessionPolicy определяет набор правил безопасности и времени жизни для группы сессий.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SessionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Время жизни сессии в секундах. 0 означает "бессрочная".
    #[prost(uint32, tag = "4")]
    pub expires_in_seconds: u32,
    /// Время неактивности в секундах, после которого сессия истекает. 0 означает "не проверять".
    #[prost(uint32, tag = "5")]
    pub inactivity_timeout_seconds: u32,
    /// Максимальное количество одновременных активных сессий для одного пользователя.
    #[prost(uint32, tag = "6")]
    pub max_concurrent_sessions: u32,
    /// Требовать ли, чтобы IP-адрес сессии не менялся.
    #[prost(bool, tag = "7")]
    pub bind_to_ip: bool,
    #[prost(uint64, tag = "8")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SessionPolicy`.
pub mod session_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SessionPolicy>,
    }
}
/// Slot представляет собой ячейку или позицию в иерархической структуре (Tree).
/// Каждый слот принадлежит определенному дистрибьютору (Distributor).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Slot {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего слота
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Порядковый идентификатор слота в рамках вышестоящего слота (parent_id)
    #[prost(uint32, tag = "3")]
    pub parent_entity_id: u32,
    /// Числовой идентификатор ветки от вышестоящего слота (parent_id)
    #[prost(uint32, tag = "4")]
    pub parent_branch_number: u32,
    /// ID дерева, к которому относится слот
    #[prost(uint32, tag = "5")]
    pub tree_id: u32,
    /// Порядковый идентификатор слота в рамках дерева (tree_id)
    #[prost(uint32, tag = "6")]
    pub tree_entity_id: u32,
    /// ID дистрибьютора, владеющего слотом
    #[prost(uint32, tag = "7")]
    pub distributor_id: u32,
    /// Порядковый идентификатор слота в рамках дистрибьютора (distributor_id)
    #[prost(uint32, tag = "8")]
    pub distributor_entity_id: u32,
    /// Порядковый идентификатор слота в рамках пары (tree_id и distributor_id)
    #[prost(uint32, tag = "9")]
    pub tree_distributor_entity_id: u32,
    /// ID партиции, к которому относится слот
    #[prost(uint32, tag = "10")]
    pub tree_partition_id: u32,
    /// Глобальный уровень глубины
    #[prost(uint32, tag = "11")]
    pub level: u32,
    /// Количество дочерних слотов
    #[prost(uint32, tag = "12")]
    pub children_quantity: u32,
    /// Вместимость дочерних слотов
    #[prost(uint32, tag = "13")]
    pub children_capacity: u32,
    /// Количество слотов в структуре
    #[prost(uint32, tag = "14")]
    pub structure_quantity: u32,
    /// Вместимость слотов в структуре
    #[prost(uint64, tag = "15")]
    pub structure_capacity: u64,
    /// Последний ID слота в структуре
    #[prost(uint32, tag = "16")]
    pub structure_last_id: u32,
    /// Максимальный уровень слота в структуре
    #[prost(uint32, tag = "17")]
    pub structure_level_max: u32,
    #[prost(uint64, tag = "18")]
    pub trace_id: u64,
    /// ID политики, применяемой к этому слоту.
    #[prost(uint32, tag = "19")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "20")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "21")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Slot`.
pub mod slot {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации слота
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3, 4, 5, 6")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentBranch {
            /// ID вышестоящего слота
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Числовой идентификатор ветки от вышестоящего слота (parent_id)
            #[prost(uint32, tag = "2")]
            pub parent_branch_number: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParentEntity {
            /// ID вышестоящего слота
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Порядковый идентификатор слота в рамках вышестоящего слота (parent_id)
            #[prost(uint32, tag = "2")]
            pub parent_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeEntity {
            /// ID дерева, к которому относится слот
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Порядковый идентификатор слота в рамках дерева (tree_id)
            #[prost(uint32, tag = "2")]
            pub tree_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DistributorEntity {
            /// ID дистрибьютора, владеющего слотом
            #[prost(uint32, tag = "1")]
            pub distributor_id: u32,
            /// Порядковый идентификатор слота в рамках дистрибьютора (distributor_id)
            #[prost(uint32, tag = "2")]
            pub distributor_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeDistributorEntity {
            /// ID дерева, к которому относится слот
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// ID дистрибьютора, владеющего слотом
            #[prost(uint32, tag = "2")]
            pub distributor_id: u32,
            /// Порядковый идентификатор слота в рамках пары (tree_id и distributor_id)
            #[prost(uint32, tag = "3")]
            pub tree_distributor_entity_id: u32,
        }
        /// Различные способы идентификации слота
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID слота
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по вышестоящему слоту и номеру ветки
            #[prost(message, tag = "2")]
            ParentBranch(ParentBranch),
            /// Идентификация слота через комбинацию ID вышестоящего слота и порядкового идентификатора слота в рамках вышестоящего слота
            #[prost(message, tag = "3")]
            ParentEntity(ParentEntity),
            /// Идентификация слота через комбинацию ID дерева и порядкового идентификатора слота в рамках этого дерева
            #[prost(message, tag = "4")]
            TreeEntity(TreeEntity),
            /// Идентификация слота через комбинацию ID дистрибьютора и порядкового идентификатора слота в рамках этого дистрибьютора
            #[prost(message, tag = "5")]
            DistributorEntity(DistributorEntity),
            /// Идентификация слота через комбинацию ID дерева, ID дистрибьютора и порядкового идентификатора слота в рамках этой пары
            #[prost(message, tag = "6")]
            TreeDistributorEntity(TreeDistributorEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Slot>,
    }
}
/// SlotPolicy определяет набор правил для группы слотов.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotPolicy`.
pub mod slot_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotPolicy>,
    }
}
/// SlotBranch представляет собой иерархическую связь или "ветку" между слотами.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotBranch {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего слота
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Числовой идентификатор ветки от вышестоящего слота
    #[prost(uint32, tag = "3")]
    pub parent_branch_number: u32,
    /// ID дочернего слота, если ветка занята
    #[prost(uint32, optional, tag = "4")]
    pub child_id: ::core::option::Option<u32>,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, управляющая поведением ветки (например, начисление бонусов).
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `SlotBranch`.
pub mod slot_branch {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID ветки слота
            #[prost(uint32, tag = "1")]
            Id(u32),
            #[prost(message, tag = "2")]
            ParentBranch(super::super::slot::id::ParentBranch),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotBranch>,
    }
}
/// SlotBranchPolicy определяет набор правил для группы веток слотов.
/// Конкретная логика политики (например, начисление особых бонусов) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotBranchPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotBranchPolicy`.
pub mod slot_branch_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotBranchPolicy>,
    }
}
/// Sort определяет порядок и количество записей в запросах на получение списков.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Sort {
    /// Направление сортировки.
    #[prost(enumeration = "sort::Direction", tag = "1")]
    pub direction: i32,
    /// Лимит записей (например, для пагинации).
    #[prost(uint32, tag = "2")]
    pub limit: u32,
}
/// Nested message and enum types in `Sort`.
pub mod sort {
    /// Направление сортировки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        /// Направление не указано. Поведение по умолчанию (обычно BACKWARD) определяется на бэкенде.
        Unspecified = 0,
        /// Прямой порядок (от старых к новым, от меньшего ID к большему).
        Forward = 1,
        /// Обратный порядок (от новых к старым, от большего ID к меньшему).
        Backward = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Forward => "FORWARD",
                Self::Backward => "BACKWARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "FORWARD" => Some(Self::Forward),
                "BACKWARD" => Some(Self::Backward),
                _ => None,
            }
        }
    }
}
/// Subject представляет собой субъект или объект, над которым было совершено действие.
/// Это типобезопасный указатель на любую ключевую сущность в системе.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Subject {
    #[prost(oneof = "subject::Entity", tags = "1, 2, 3")]
    pub entity: ::core::option::Option<subject::Entity>,
}
/// Nested message and enum types in `Subject`.
pub mod subject {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Entity {
        #[prost(uint32, tag = "1")]
        AccountId(u32),
        #[prost(uint32, tag = "2")]
        CurrencyId(u32),
        /// ... и другие важные сущности могут быть добавлены в будущем
        #[prost(uint32, tag = "3")]
        BonusId(u32),
    }
}
/// Trace представляет собой полную трассировку одной бизнес-операции, состоящую из плоского списка шагов (spans).
/// Иерархия шагов строится на клиенте с использованием поля `parent_id`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    /// Глобальный УНИКАЛЬНЫЙ ID всей бизнес-операции.
    #[prost(uint64, tag = "1")]
    pub trace_id: u64,
    /// Аккаунт, который ИНИЦИИРОВАЛ всю операцию. Если пуст - действие системное.
    #[prost(uint32, optional, tag = "2")]
    pub actor_id: ::core::option::Option<u32>,
    /// Плоский список всех шагов, произошедших в рамках этой операции.
    #[prost(message, repeated, tag = "3")]
    pub spans: ::prost::alloc::vec::Vec<trace::Span>,
}
/// Nested message and enum types in `Trace`.
pub mod trace {
    /// Span представляет один, конкретный, атомарный шаг (операцию) в трассировке.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Span {
        /// Уникальный ID самого шага (span'а).
        #[prost(uint64, tag = "1")]
        pub id: u64,
        /// ID родительского шага. Равен 0 для корневого шага.
        #[prost(uint64, tag = "2")]
        pub parent_id: u64,
        /// Техническое имя операции (например, "CreateLedgerTransaction").
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        /// Статус выполнения этого шага.
        #[prost(enumeration = "span::Status", tag = "4")]
        pub status: i32,
        /// Сообщение об ошибке, если status = FAILURE.
        #[prost(string, optional, tag = "5")]
        pub error_message: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "6")]
        pub started_at: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "7")]
        pub finished_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Контекст, специфичный для этого шага (например, ID созданной транзакции, сумма и т.д.).
        #[prost(message, optional, tag = "8")]
        pub context: ::core::option::Option<::prost_types::Any>,
    }
    /// Nested message and enum types in `Span`.
    pub mod span {
        /// Статус выполнения шага.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            Unspecified = 0,
            /// Шаг успешно выполнен.
            Success = 1,
            /// В процессе выполнения шага произошла ошибка.
            Failure = 2,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Success => "SUCCESS",
                    Self::Failure => "FAILURE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "SUCCESS" => Some(Self::Success),
                    "FAILURE" => Some(Self::Failure),
                    _ => None,
                }
            }
        }
    }
}
/// Tree представляет собой основную иерархическую структуру или сеть.
/// Она служит контейнером для слотов, дистрибьюторов и партиций.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Tree {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное строковое имя для идентификации дерева
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ID сети, к которой принадлежит дерево
    #[prost(uint32, tag = "3")]
    pub network_id: u32,
    /// Порядковый идентификатор дерева в рамках сети (network_id)
    #[prost(uint32, tag = "4")]
    pub network_entity_id: u32,
    /// ID корневой партиции (TreePartition) для данного дерева
    #[prost(uint32, tag = "5")]
    pub root_partition_id: u32,
    /// Вместимость дочерних слотов по умолчанию. Используется для визуализации структуры.
    #[prost(uint32, tag = "6")]
    pub slot_children_capacity_default: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    /// Политика, управляющая поведением всего дерева.
    #[prost(uint32, tag = "8")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Tree`.
pub mod tree {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации дерева
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по сети и порядковому номеру
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkEntity {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор дерева в рамках сети
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        /// Различные способы идентификации дерева
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID дерева
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя дерева
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
            /// Идентификация по сети и порядковому номеру
            #[prost(message, tag = "3")]
            NetworkEntity(NetworkEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Tree>,
    }
}
/// TreeDistributorPolicy определяет набор правил для группы связей TreeDistributor.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreeDistributorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreeDistributorPolicy`.
pub mod tree_distributor_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreeDistributorPolicy>,
    }
}
/// TreeDistributor представляет собой связь между деревом (Tree) и дистрибьютором (Distributor).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreeDistributor {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Идентификатор дерева
    #[prost(uint32, tag = "2")]
    pub tree_id: u32,
    /// Порядковый номер связи в рамках дерева (tree_id)
    #[prost(uint32, tag = "3")]
    pub tree_entity_id: u32,
    /// Идентификатор дистрибьютора
    #[prost(uint32, tag = "4")]
    pub distributor_id: u32,
    /// Порядковый номер связи в рамках дистрибьютора (distributor_id)
    #[prost(uint32, tag = "5")]
    pub distributor_entity_id: u32,
    /// ID политики, применяемой к этой связи. Определяет ее статус и правила.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TreeDistributor`.
pub mod tree_distributor {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации связи
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Составной идентификатор для связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Pair {
            /// Идентификатор дерева
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Идентификатор дистрибьютора
            #[prost(uint32, tag = "2")]
            pub distributor_id: u32,
        }
        /// Различные способы идентификации связи
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID связи
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по паре дерево-дистрибьютор
            #[prost(message, tag = "2")]
            Pair(Pair),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreeDistributor>,
    }
}
/// TreePolicy определяет набор правил для группы деревьев.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreePolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePolicy`.
pub mod tree_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePolicy>,
    }
}
/// TreePartitionPolicy определяет набор правил для группы партиций дерева.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreePartitionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Определяет, могут ли партиции, подчиненные этой политике, быть слиты с другими. false - аналог "Standalone".
    #[prost(bool, tag = "4")]
    pub is_mergeable: bool,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePartitionPolicy`.
pub mod tree_partition_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePartitionPolicy>,
    }
}
/// TreePartition представляет собой выделенную часть или "партицию" внутри дерева (Tree).
/// Партиция начинается с определенного корневого слота и может функционировать как отдельное поддерево.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TreePartition {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID родительского дерева
    #[prost(uint32, tag = "2")]
    pub tree_id: u32,
    /// Порядковый номер партиции в рамках дерева
    #[prost(uint32, tag = "3")]
    pub tree_entity_id: u32,
    /// ID корневого слота, с которого начинается партиция
    #[prost(uint32, tag = "4")]
    pub root_slot_id: u32,
    /// Политика, управляющая поведением партиции (например, возможностью слияния).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    /// Флаг, указывающий, что партиция была слита с другой и больше не активна.
    #[prost(bool, tag = "6")]
    pub is_archived: bool,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `TreePartition`.
pub mod tree_partition {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации партиции
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по порядковому номеру в дереве
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeEntity {
            /// Идентификатор дерева
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Порядковый идентификатор партиции в рамках дерева
            #[prost(uint32, tag = "2")]
            pub tree_entity_id: u32,
        }
        /// Различные способы идентификации партиции
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID партиции
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по дереву и порядковому номеру
            #[prost(message, tag = "2")]
            Entity(TreeEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePartition>,
    }
}
/// UserPolicy определяет набор правил для группы пользователей.
/// Конкретная логика политики (например, требования к верификации) реализуется на бэкенде.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `UserPolicy`.
pub mod user_policy {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::UserPolicy>,
    }
}
/// WalletOperation определяет типы операций, которые могут быть разрешены или запрещены.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WalletOperation {}
/// Nested message and enum types in `WalletOperation`.
pub mod wallet_operation {
    /// Id представляет собой порядковый номер бита в маске.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Id {
        /// Депозиты (ввод средств).
        Deposit = 0,
        /// Выводы (вывод средств).
        Withdraw = 1,
        /// Отправка внутреннего перевода.
        InternalTransferSend = 2,
        /// Получение внутреннего перевода.
        InternalTransferReceive = 3,
        /// Платежи (оплата внутренних услуг, подписок).
        Payment = 4,
    }
    impl Id {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Deposit => "DEPOSIT",
                Self::Withdraw => "WITHDRAW",
                Self::InternalTransferSend => "INTERNAL_TRANSFER_SEND",
                Self::InternalTransferReceive => "INTERNAL_TRANSFER_RECEIVE",
                Self::Payment => "PAYMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEPOSIT" => Some(Self::Deposit),
                "WITHDRAW" => Some(Self::Withdraw),
                "INTERNAL_TRANSFER_SEND" => Some(Self::InternalTransferSend),
                "INTERNAL_TRANSFER_RECEIVE" => Some(Self::InternalTransferReceive),
                "PAYMENT" => Some(Self::Payment),
                _ => None,
            }
        }
    }
}
/// WalletType - тип кошелька (например, "Спотовый", "Маржинальный").
/// Определяет, какие валюты в принципе могут быть в кошельках данного типа.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WalletType {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальный код типа ("SPOT", "MARGIN")
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    /// Человекочитаемое имя ("Спотовый кошелек")
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Описание
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Статус жизненного цикла.
    #[prost(enumeration = "wallet_type::status::Id", tag = "5")]
    pub status: i32,
    /// Битовая маска флагов разрешенных операций. Позиции битов определяются в `WalletOperation.Id`.
    #[prost(uint32, tag = "6")]
    pub allowed_operations_flags: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `WalletType`.
pub mod wallet_type {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный код, например "SPOT", "MARGIN"
            #[prost(string, tag = "2")]
            Code(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::WalletType>,
    }
    /// Статус жизненного цикла типа кошелька.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Тип кошелька активен и доступен.
            Active = 1,
            /// Временно на тех. обслуживании.
            Maintenance = 2,
            /// Устарел и больше не используется.
            Deprecated = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Maintenance => "MAINTENANCE",
                    Self::Deprecated => "DEPRECATED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "MAINTENANCE" => Some(Self::Maintenance),
                    "DEPRECATED" => Some(Self::Deprecated),
                    _ => None,
                }
            }
        }
    }
}
/// WalletTypeCurrency - связь между типом кошелька и валютой.
/// Определяет, доступна ли валюта в данном типе кошелька и с какими ограничениями.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WalletTypeCurrency {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<wallet_type_currency::Id>,
    /// "Мастер-выключатель". Если true, валюта полностью отключена в этом типе кошелька.
    #[prost(bool, tag = "2")]
    pub disabled: bool,
    /// Битовая маска флагов запрещенных операций. Позиции битов определяются в `WalletOperation.Id`.
    #[prost(uint32, tag = "3")]
    pub disabled_operations_flags: u32,
    /// Настройки для внутренних переводов.
    #[prost(message, optional, tag = "4")]
    pub internal_transfer_settings: ::core::option::Option<
        wallet_type_currency::InternalTransferSettings,
    >,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `WalletTypeCurrency`.
pub mod wallet_type_currency {
    /// Составной идентификатор.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint32, tag = "1")]
        pub wallet_type_id: u32,
        #[prost(uint32, tag = "2")]
        pub currency_id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::WalletTypeCurrency>,
    }
    /// Настройки для внутренних переводов.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InternalTransferSettings {
        /// Минимальная сумма одного перевода.
        #[prost(string, optional, tag = "1")]
        pub min_amount: ::core::option::Option<::prost::alloc::string::String>,
        /// Максимальная сумма одного перевода.
        #[prost(string, optional, tag = "2")]
        pub max_amount: ::core::option::Option<::prost::alloc::string::String>,
        /// Комиссия, взимаемая за исходящий перевод.
        #[prost(message, optional, tag = "3")]
        pub outgoing_fee: ::core::option::Option<super::CalculationGroup>,
    }
}
/// Wallet - это экземпляр кошелька, принадлежащий конкретному владельцу (Account).
/// Он создается на основе WalletType и содержит набор счетов (Ledger) для каждой валюты.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Wallet {
    /// ID типа, на основе которого создан кошелек.
    #[prost(uint32, tag = "1")]
    pub wallet_type_id: u32,
    /// Текущий статус этого экземпляра кошелька.
    #[prost(enumeration = "wallet::status::Id", tag = "2")]
    pub status: i32,
    /// Битовая маска флагов операций, принудительно запрещенных для этого конкретного экземпляра кошелька.
    /// Позиции битов определяются в `WalletOperation.Id`.
    #[prost(uint32, tag = "3")]
    pub disabled_operations_flags: u32,
    /// Флаг, указывающий, что объект был инициализирован и не является значением по умолчанию.
    #[prost(bool, tag = "4")]
    pub initialized: bool,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Wallet`.
pub mod wallet {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Wallet>,
    }
    /// Статус жизненного цикла экземпляра кошелька.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            Unspecified = 0,
            /// Кошелек активен и работает штатно.
            Active = 1,
            /// Кошелек заморожен администратором. Все операции заблокированы.
            Frozen = 2,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Frozen => "FROZEN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "FROZEN" => Some(Self::Frozen),
                    _ => None,
                }
            }
        }
    }
}
/// WalletCurrency - это подробное представление баланса одной валюты в кошельке пользователя.
/// Оно объединяет подтвержденный баланс с агрегированными данными о транзакциях в ожидании.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WalletCurrency {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<wallet_currency::Id>,
    /// Основной объект бухгалтерского счета, содержащий все балансовые показатели.
    #[prost(message, optional, tag = "2")]
    pub ledger: ::core::option::Option<Ledger>,
    /// "Мастер-выключатель". Если true, валюта полностью отключена для этой валюты в этом кошельке.
    #[prost(bool, tag = "3")]
    pub disabled: bool,
    /// Битовая маска флагов операций, принудительно запрещенных для этой валюты в данном кошельке.
    /// Позиции битов определяются в `WalletOperation.Id`.
    #[prost(uint32, tag = "4")]
    pub disabled_operations_flags: u32,
    /// Флаг, указывающий, что объект был инициализирован и не является значением по умолчанию.
    #[prost(bool, tag = "5")]
    pub initialized: bool,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `WalletCurrency`.
pub mod wallet_currency {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// ID типа кошелька.
        #[prost(uint32, tag = "1")]
        pub wallet_type_id: u32,
        /// ID валюты.
        #[prost(uint32, tag = "2")]
        pub currency_id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::WalletCurrency>,
    }
}
