syntax = "proto3";

package biconom.client.payment_network_currency;

import "biconom/types/payment_instrument.proto";
import "biconom/types/currency.proto";
import "biconom/types/payment_network.proto";
import "biconom/types/payment_network_currency.proto";
import "biconom/types/sort.proto";

// Сервис для получения информации о поддержке валют в платежных сетях.
service PaymentNetworkCurrencyService {
	// Получить информацию о конкретной связке "сеть-валюта" по ее составному ключу.
	rpc Get(biconom.types.PaymentNetworkCurrency.Id) returns (biconom.types.PaymentNetworkCurrency);

	// Получить список связок "сеть-валюта" с фильтрацией и пагинацией.
	rpc List(ListRequest) returns (biconom.types.PaymentNetworkCurrency.List);

	// Получить или сгенерировать реквизиты для пополнения для текущего пользователя.
	// ID аккаунта берется из контекста авторизации.
	rpc GetDepositAddress(biconom.types.PaymentNetworkCurrency.Id) returns (DepositAddress);

	// Проверяет, являются ли предоставленные реквизиты (`instrument`) валидными для указанной пары "сеть-валюта".
	rpc ValidateInstrument(ValidateInstrumentRequest) returns (ValidateInstrumentResponse);

	// Рассчитывает комиссию для вывода по указанным параметрам.
	rpc CalculateWithdrawalFee(CalculateWithdrawalFeeRequest) returns (CalculateWithdrawalFeeResponse);
}

// DepositAddress представляет собой набор реквизитов для пополнения счета.
message DepositAddress {
    // Реквизиты для пополнения через блокчейн.
    message Blockchain {
        // Адрес для пополнения.
        string address = 1;
        // Значение memo/tag, если оно было сгенерировано для пользователя.
        optional string memo = 2;
    }

    oneof kind {
        Blockchain blockchain = 1;
    }
}

// Запрос на получение списка связок "сеть-валюта".
message ListRequest {
	// Фильтр по одной или нескольким платежным сетям.
	repeated biconom.types.PaymentNetwork.Id filter_payment_network_ids = 1;

	// Фильтр по одной или нескольким валютам.
	repeated biconom.types.Currency.Id filter_currency_ids = 2;

	// Фильтр по статусу связки.
	repeated biconom.types.PaymentNetworkCurrency.Status.Id filter_statuses = 3;

	// Курсор для пагинации. В качестве значения используется составной ключ
	// (payment_network_id, currency_id) последней полученной записи.
	optional biconom.types.PaymentNetworkCurrency.Id cursor = 4;

	optional biconom.types.Sort sort = 5;
}

// Запрос на валидацию реквизитов.
message ValidateInstrumentRequest {
	// Контекст: ID платежной сети, для которой выполняется проверка.
	uint32 payment_network_id = 1;

	// Контекст: ID валюты, для которой выполняется проверка.
	uint32 currency_id = 2;

	// Реквизиты, которые нужно проверить.
	biconom.types.PaymentInstrument instrument = 3;
}

// Ответ на запрос валидации реквизитов.
message ValidateInstrumentResponse {
	// Результат проверки.
	bool is_valid = 1;

	// Отформатированные/нормализованные реквизиты, если бэкенд выполнил их преобразование.
	optional biconom.types.PaymentInstrument formatted_instrument = 2;
}

// Запрос на расчет комиссии за вывод.
message CalculateWithdrawalFeeRequest {
    // ID платежной сети.
    uint32 payment_network_id = 1;
    // ID валюты.
    uint32 currency_id = 2;
    // Сумма вывода, для которой нужно рассчитать комиссию.
    string amount = 3;
    // Флаг, указывающий, как комиссия должна быть обработана.
    // `true`: получатель получит `amount - fee`.
    // `false` (по умолчанию): получатель получит `amount`, а с баланса будет списано `amount + fee`.
    // Этот флаг влияет на итоговую сумму `amount_to_receive` в ответе.
    bool deduct_fee_from_amount = 4;
}

// Ответ с рассчитанной комиссией.
message CalculateWithdrawalFeeResponse {
    // Детализация комиссии. Ключ - название компонента комиссии (из CalculationGroup),
    // значение - рассчитанная сумма для этого компонента.
    map<string, string> fee_breakdown = 1;
    // Итоговая сумма, которую получит адресат после вычета всех комиссий.
    string amount_to_receive = 2;
}