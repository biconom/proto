syntax = "proto3";

package biconom.client.marketing;

import "biconom/types/slot.proto";
import "biconom/types/marketing_slot.proto";
import "biconom/types/license.proto";
import "google/protobuf/empty.proto";
import "biconom/types/account.proto";
import "biconom/types/distributor.proto";
import "biconom/types/price.proto";
import "biconom/types/relationship.proto";
import "biconom/types/sort.proto";
import "google/protobuf/timestamp.proto";

// MarketingService предоставляет функционал для управления аффилейт маркетингом,
// включая работу со слотами, подписками и расширением структуры.
service MarketingService {

    // =========================================================================
    // Контекст авторизации: distributor_id
    // Методы, требующие авторизации от имени дистрибьютора.
    // =========================================================================

    // Получить список состояний всех собственных слотов дистрибьютора.
    rpc ListOwnSlotStates(google.protobuf.Empty) returns (biconom.types.MarketingSlot.State.List);

    // Получить тарифный план по идентификатору.
    rpc GetLicensePlan(biconom.types.License.Plan.Id) returns (biconom.types.License.Plan);

    // Получить список доступных тарифных планов подписки.
    rpc ListLicensePlans(google.protobuf.Empty) returns (biconom.types.License.Plan.List);

    // Приобрести тарифный план подписки.
    // При повторной покупке создаются дополнительные ваучеры, продлевающие период действия.
    rpc PurchaseLicensePlan(PurchaseLicensePlanRequest) returns (biconom.types.MarketingSlot.State);

    // Получить список слотов, ожидающих ручной расстановки.
    rpc ListPendingManualPlacementSlots(ListPendingManualPlacementSlotsRequest) returns (ListUnplacedSlotsResponse);

    // Получить список потенциальных слотов, которые могут попасть к дистрибьютору благодаря компрессии
    // неактивных уровней снизу по иерархии.
    rpc ListPotentialCompressionSlots(ListPotentialCompressionSlotsRequest) returns (ListUnplacedSlotsResponse);

    // =========================================================================
    // Контекст авторизации: slot_id
    // Методы, требующие авторизации от имени конкретного слота.
    // =========================================================================

    // Получить детальную информацию о выбранном слоте.
    rpc GetSlot(biconom.types.Slot.Id) returns (biconom.types.MarketingSlot);

    // Деактивировать автопродление подписки для текущего слота.
    rpc DeactivateAutoRenewal(google.protobuf.Empty) returns (biconom.types.MarketingSlot.State);
    // Восстановить автопродление подписки для текущего слота.
    rpc RestoreAutoRenewal(google.protobuf.Empty) returns (biconom.types.MarketingSlot.State);

    // Поиск слотов в иерархии по логину дистрибьютора.
    rpc SearchSlots(SearchSlotsRequest) returns (SearchSlotsResponse);

    // Рассчитать стоимость увеличения вместимости первой линии (ширины) слота.
    rpc CalculateCapacityUpgradePrice(CapacityUpgradeRequest) returns (biconom.types.Price);
    // Приобрести увеличение вместимости первой линии.
    rpc PurchaseCapacityUpgrade(CapacityUpgradeRequest) returns (biconom.types.Slot);

    // Рассчитать стоимость и предпросмотр расстановки слота (автоматической или ручной).
    // Если target_location не передан, рассчитывается автоматическое место.
    rpc CalculateManualPlacementPrice(ManualPlacementRequest) returns (CalculateManualPlacementPriceResponse);

    // Оплатить возможность досрочного расставления (ручная расстановка).
    // Если целевая позиция совпадает с автоматической, оплата может быть нулевой, но операция фиксируется.
    rpc PurchaseManualPlacement(ManualPlacementRequest) returns (biconom.types.MarketingSlot);
}

// Запрос на поиск слотов по префиксу имени пользователя дистрибьютора.
message SearchSlotsRequest {
    // Префикс логина (username) дистрибьютора для поиска.
    string username_prefix = 1;

    // Опционально: ограничение количества результатов.
    optional uint32 limit = 2;

    // Фильтр по типу иерархической связи ДИСТРИБЬЮТОРОВ (реферальная структура).
    // Если поле не заполнено, поиск производится без учета иерархической связи дистрибьюторов.
    repeated biconom.types.Relationship.State.Kind filter_distributor_relationship_state_kinds = 3;

    // Фильтр по типу иерархической связи СЛОТОВ (маркетинговая структура).
    // Если поле не заполнено, поиск производится без учета иерархической связи слотов.
    repeated biconom.types.Relationship.State.Kind filter_slot_relationship_state_kinds = 4;

    // --- Параметры глубины поиска (опционально) ---

    // Лимит глубины поиска по иерархии ДИСТРИБЬЮТОРОВ вверх (родители/спонсоры).
    optional uint32 filter_distributor_depth_limit_up = 5;
    // Лимит глубины поиска по иерархии ДИСТРИБЬЮТОРОВ вниз (команда/рефералы).
    optional uint32 filter_distributor_depth_limit_down = 6;

    // Лимит глубины поиска по иерархии СЛОТОВ вверх (аплайны).
    optional uint32 filter_slot_depth_limit_up = 7;
    // Лимит глубины поиска по иерархии СЛОТОВ вниз (структура).
    optional uint32 filter_slot_depth_limit_down = 8;

    // Фильтр по деревьям (маркетинговым структурам).
    repeated uint32 tree_ids = 9;
}

// Ответ на поиск слотов, содержащий плоские списки найденных сущностей.
message SearchSlotsResponse {
    // Список найденных слотов, удовлетворяющих условиям поиска.
    repeated biconom.types.Slot slots = 1;
    // Список состояний для найденных слотов.
    repeated biconom.types.MarketingSlot.State slot_states = 2;
    // Список дистрибьюторов-владельцев найденных слотов.
    repeated biconom.types.Distributor distributors = 3;
    // Список аккаунтов-владельцев дистрибьюторов.
    repeated biconom.types.Account accounts = 4;
}

// Запрос на покупку тарифного плана лицензии.
message PurchaseLicensePlanRequest {
    // Идентификатор дерева, в котором приобретается план.
    uint32 tree_id = 1;
    // Количество ваучеров для покупки за один запрос.
    uint32 quantity = 2;
}

// Запрос на изменение вместимости (ширины) первой линии слота.
message CapacityUpgradeRequest {
    // Желаемое итоговое количество мест в первой линии (должно быть больше текущего).
    uint32 target_children_capacity = 1;
}

// Запрос на получение списка слотов для ручной расстановки.
message ListPendingManualPlacementSlotsRequest {
    // Опционально: идентификатор дистрибьютора. Если не указан — используется авторизованный дистрибьютор.
    optional biconom.types.Distributor.Id distributor_id = 1;
    // Опционально: фильтр по дерева. Если не указан — возвращаются слоты по всем деревьям.
    optional uint32 tree_id = 2;
    // Опционально: курсор для пагинации (ID последнего полученного слота).
    optional biconom.types.Slot.Id cursor = 3;
    // Опционально: параметры сортировки.
    optional biconom.types.Sort sort = 4;
}

// Ответ со списком нерасставленных слотов и связанными данными.
// Используется как для ListPendingManualPlacementSlots, так и для ListPotentialCompressionSlots.
message ListUnplacedSlotsResponse {
    // Общее количество нерасставленных слотов (для пагинации).
    uint32 total_count = 1;

    // Нерасставленный слот с информацией о сроках.
    message UnplacedSlot {
        uint32 slot_id = 1; // ID слота, который нужно расставить.
        optional google.protobuf.Timestamp auto_placement_at = 2; // Время автоматической расстановки (если применимо).
    }

    // Список нерасставленных слотов.
    repeated UnplacedSlot items = 2;

    // --- Связанные данные для обогащения интерфейса ---
    repeated biconom.types.Slot slots = 3;
    repeated biconom.types.MarketingSlot.State slot_states = 4;
    repeated biconom.types.Distributor distributors = 5;
    repeated biconom.types.Account accounts = 6;
    repeated biconom.types.MarketingSlot.DistributorState distributor_states = 7;
}

// Запрос на получение списка потенциальных слотов компрессии.
message ListPotentialCompressionSlotsRequest {
    // Опционально: фильтр по дереву. Если не указан — возвращаются слоты по всем деревьям.
    optional uint32 tree_id = 1;
    // Опционально: курсор для пагинации.
    optional biconom.types.Slot.Id cursor = 2;
    // Опционально: параметры сортировки.
    optional biconom.types.Sort sort = 3;
}

// Запрос на ручную расстановку (расчет или покупка).
message ManualPlacementRequest {
    // ID слота, который необходимо расставить (из списка ожидания).
    biconom.types.Slot.Id slot_id = 1;

    // Опционально: Целевое место расстановки (ID родителя и номер ветки).
    // Если не указано, будет использовано место, выбранное алгоритмом автоматической расстановки.
    optional biconom.types.Slot.Id.ParentBranch target_location = 2;
}

// Ответ с расчетом стоимости и предпросмотром расстановки.
message CalculateManualPlacementPriceResponse {
    // --- Данные контекста ---
    uint32 executor_slot_id = 1;
    uint32 target_slot_id = 2; // ID слота, для которого выполняется расчет.

    // --- Данные целевого выбора (пользователя или авто-алгоритма) ---
    uint32 target_parent_id = 3; // ID родительского слота (выбранного вручную или автоматически).
    uint32 target_parent_branch_number = 4; // Ветка (выбранная вручную или автоматически).
    
    // --- Данные автоматического прогноза ---
    uint32 predicted_parent_id = 5; // ID слота, куда бы встал слот автоматически.
    uint32 predicted_parent_branch_number = 6; // Ветка, куда бы встал слот автоматически.

    // --- Данные стоимости ---
    biconom.types.Price price = 7; // Стоимость расстановки в target_parent_id (0 при совпадении с predicted).
    
    // Хлебные крошки до target_parent_id.
    repeated biconom.types.MarketingSlot.Breadcrumb breadcrumbs = 8;
    // Цепочки выбранного родителя (target_parent_id).
    repeated biconom.types.MarketingSlot.Chain view_chains = 9;

    // --- Связанные данные ---
    repeated biconom.types.MarketingSlot.State slot_states = 10;
    repeated biconom.types.Slot slots = 11;
    repeated biconom.types.Distributor distributors = 12;
    repeated biconom.types.Account accounts = 13;
    repeated biconom.types.MarketingSlot.DistributorState distributor_states = 14;
}
